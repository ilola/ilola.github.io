<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>کتاب پایتون ۳</title>
	<atom:link href="http://192.168.1.6/feed/" rel="self" type="application/rss+xml" />
	<link>http://192.168.1.6</link>
	<description>دانلود کتاب پایتون 3 برای تازه کاران</description>
	<lastBuildDate>Sun, 07 Oct 2018 08:48:09 +0000</lastBuildDate>
	<language>fa-IR</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.9.8</generator>

<image>
	<url>http://192.168.1.6/contents/data/2018/10/cropped-python3-32x32.png</url>
	<title>کتاب پایتون ۳</title>
	<link>http://192.168.1.6</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>پایتون برای همه &#124; 34 &#124; فایل متنی و خطوط</title>
		<link>http://192.168.1.6/1644/</link>
		<comments>http://192.168.1.6/1644/#comments</comments>
		<pubDate>Fri, 06 Oct 2017 07:26:38 +0000</pubDate>
		<dc:creator><![CDATA[Eman]]></dc:creator>
				<category><![CDATA[برنامه‌نویسی]]></category>

		<guid isPermaLink="false">https://ilola.ir/?p=1644</guid>
		<description><![CDATA[یک فایل متنی را می‌توان سلسله‌ای از خطوط در نظر گرفت. درست مثل سلسله‌ای از کاراکترها که در پایتون یک رشته خوانده می‌شود. نوشته‌ی زیر، <a class="mh-excerpt-more" href="http://192.168.1.6/1644/" title="پایتون برای همه &#124; 34 &#124; فایل متنی و خطوط">[...]</a>]]></description>
				<content:encoded><![CDATA[<p>یک فایل متنی را می‌توان سلسله‌ای از خطوط در نظر گرفت. درست مثل سلسله‌ای از کاراکترها که در پایتون یک رشته خوانده می‌شود. نوشته‌ی زیر، یک فایل متنی‌ست که فعالیت‌های مرتبط با ایمیل را از افراد متفاوت جمع‌آوری می‌کند؛ این فایل از یک پروژه‌ی متن‌باز به عاریت گرفته شده است:</p>
<p></p><pre class="crayon-plain-tag">From stephen.marquard@uct.ac.za Sat Jan 5 09:14:16 2008
Return-Path: &lt;postmaster@collab.sakaiproject.org&gt;
Date: Sat, 5 Jan 2008 09:12:18 -0500
To: source@collab.sakaiproject.org
From: stephen.marquard@uct.ac.za
Subject: [sakai] svn commit: r39772 - content/branches/
Details: http://source.sakaiproject.org/viewsvn/?view=rev&amp;rev=39772
...</pre><p> </p>
<p>کل فایل متنی را می‌توانید از لینک زیر دریافت کنید:<br />
<a href="http://www.py4e.com/code3/mbox.txt">لینک</a></p>
<p>همچنین یک نسخه‌ی خلاصه‌شده‌ی آن در لینک زیر در دسترس است:<br />
<a href="http://www.py4e.com/code3/mbox-short.txt">لینک</a></p>
<p>فرمت این فایل‌ها استاندارد است و شامل چندین پیام پستی می‌شود. خطوطی که با کلمه‎ ‎&#8221;From&#8221;‎ آغاز می‌شوند، پیام‌ها را جدا کرده و خطوطی که با ‎&#8221;From:‎&#8221;‎ شروع می‌شوند، قسمتی از آن پیام‌ها هستند. برای اطلاعات بیشتر در خصوص فرمت mbox این صفحه را ببیند:<br />
<a href="http://en.wikipedia.org/wiki/Mbox" target="_blank">لینک</a></p>
<p>برای شکستن فایل به خطوط، کاراکتر ویژه‌ای که نشان‌دهنده‌ی پایان خط است وجود دارد. این کاراکتر newline یا خط‌جدید خوانده می‌شود.</p>
<p>پایتون کاراکتر خط‌جدید را با یک بک‌اسلش و n مشخص می‌کند. اگرچه ‎n به نظر دو کاراکتر است، ولی در اصل یک کاراکتر خوانده می‌شود. فرض کنید که ما این کاراکتر را در داخل متغیری با نام stuff قرار می‌دهیم. حالا اگر در داخل مفسر stuff را وارد کنیم، این کاراکتر هم نمایش داده می‌شود، ولی اگر از print استفاده کنیم، رشته‌ی ما به دو خط شکسته می‌شود. </p>
<p>در اصل در حین چاپ کردن متغیر، شما اثر کاراکتر ‎n را خواهید دید، و نه خود کاراکتر را. برای شفاف شدن موضوع به مثال زیر دقت کنید:</p>
<p></p><pre class="crayon-plain-tag">&gt;&gt;&gt; stuff = 'HellonWorld!'
&gt;&gt;&gt; stuff
'HellonWorld!'
&gt;&gt;&gt; print(stuff)
Hello
World!
&gt;&gt;&gt; stuff = 'XnY'
&gt;&gt;&gt; print(stuff)
X
Y
&gt;&gt;&gt; len(stuff)
3</pre><p> </p>
<p>برای اینکه مطمئن شوید که ‎n تنها یک کاراکتر است بد نیست که طول رشته‌ی XnY را با پایتون اندازه بگیرید. می‌بینید که پایتون آن را سه کاراکتر در نظر می‌گیرد. در اصل ‎n یک کاراکتر به حساب آمده است.</p>
<p>به این صورت، و با تصور وجود یک نویسه‌ی نامرعی در پایان هر خط، انتهای خطوط در متن‌ها مشخص می‌شود. کافی‌ست که فقط آن را در ذهن خود تصویر کنید. این نویسه یا کاراکتر ناپیدا، همان ‎n است.</p>
<p>حرف آخر اینکه کاراکتر خط‌جدید کاراکترهای موجود در یک فایل را به خطوط جداگانه می‌شکند.</p>
<p>این نوشته تحت مجوز کرییتیو کامنز BY – NC و حمایت موسسه تحقیقاتی رامونا ارائه می‌شود. شما می‌توانید با توجه به مفاد این گواهی از آن استفاده کنید.</p>
]]></content:encoded>
			<wfw:commentRss>http://192.168.1.6/1644/feed/</wfw:commentRss>
		<slash:comments>1</slash:comments>
		</item>
		<item>
		<title>پایتون برای همه &#124; 33 &#124; فایل‌ها در پایتون &#124; ماندگاری و باز کردن فایل‌ها</title>
		<link>http://192.168.1.6/1628/</link>
		<comments>http://192.168.1.6/1628/#respond</comments>
		<pubDate>Wed, 04 Oct 2017 05:34:40 +0000</pubDate>
		<dc:creator><![CDATA[Eman]]></dc:creator>
				<category><![CDATA[برنامه‌نویسی]]></category>

		<guid isPermaLink="false">https://ilola.ir/?p=1628</guid>
		<description><![CDATA[ماندگاری فایل‌ها تا اینجا ما در خصوص نحوه‌ی نوشتن برنامه‌ها و ارتباط برقرار کردن با واحد پردازش مرکزی با استفاده از اجرای شرطی، توابع و <a class="mh-excerpt-more" href="http://192.168.1.6/1628/" title="پایتون برای همه &#124; 33 &#124; فایل‌ها در پایتون &#124; ماندگاری و باز کردن فایل‌ها">[...]</a>]]></description>
				<content:encoded><![CDATA[<h2>ماندگاری فایل‌ها</h2>
<p>تا اینجا ما در خصوص نحوه‌ی نوشتن برنامه‌ها و ارتباط برقرار کردن با واحد پردازش مرکزی با استفاده از اجرای شرطی، توابع و تکرارها آشنا شدیم. ما در خصوص چگونگی ساخت و استفاده از ساختار داده در حافظه‌ی اصلی نیز آموختیم. CPU و حافظه جایی‌اند که نرم‌افزار ما در آن‌ها کار می‌کند و اجرا می‌شود. در اصل این منطقه همان جایی‌ست که &#8220;فکر کردن&#8221; اتفاق می‌افتد.</p>
<p>ولی مشکل اینجاست که ما می‌خواهیم بحث میان سخت‌افزارهای ما ادامه داشته باشد، اما همین که برق برود و سیستم خاموش شود، تمام آنچه در CPU و حافظه اصلی بوده پاک خواهد شد. برنامه‌های پایتونی ما تلاش‌های تفریحیِ ناپایداری خواهند بود که از بین می‌روند.</p>
<p><a href="https://ilola.ir/contents/data/2017/08/07-01.gif"><img src="https://ilola.ir/contents/data/2017/08/07-01-1024x610.gif" alt="ماندگاری فایل" width="1024" height="610" class="aligncenter size-large wp-image-1630" /></a></p>
<p>در این فصل ما با حافظه‌ی جانبی (یا فایل‌ها) سر و کار داریم. اطلاعات در حافظه‌ی جانبی زمانی‌که سیستم خاموش می‌شود، از بین نمی‌رود؛ یا مثلا برنامه‌ای که نوشته‌ایم می‌تواند بر روی یک حافظه‌ی فلش کپی شده، از سیستم جدا و سپس به یک سیستم دیگر منتقل و اجرا شود.</p>
<p>تمرکز اصلی ما بر روی خواندن و نوشتن فایل‌های متنی مانند همان‌هایی که در ویرایشگر متن می‌نویسیم، خواهد بود. در ادامه یاد خواهیم گرفت که چطور با فایل‌های پایگاه داده که فایل‌های باینری‌اند کار کنیم؛ به‌خصوص آن‌ها که برای خوانده و نوشتن شدن توسط نرم‌افزارهای پایگاه‌ طراحی شده‌اند.</p>
<h2>باز کردن فایل‌ها</h2>
<p>وقتی قرار است که فایلی را بخوانیم یا بر روی آن بنویسیم (مثلا فایل‌های روی هارد دیسک شما)، ابتدا باید فایل را باز کنیم. باز کردن فایل، برقراری ارتباط با سیستم‌عامل شما به حساب می‌آید. چرا سیستم‌عامل؟ چون سیستم‌عامل است که می‌داند هر فایل در کجا ذخیره شده است. زمانی که شما یک فایل را باز می‌کنید، از سیستم‌عامل می‌پرسید که آن فایل را از طریق نامش پیدا کرده و مطمئن شود که فایل اصلا وجود دارد. در این مثال، ما فایل mbox.txt که در همان فولدر جاری است را باز می‌کنیم؛ منظورمان از فولدر جاری، همان مسیری‌ست که پایتون در آن اجرا شده است. شما می‌توانید فایل را از طریق این لینک دانلود کنید:</p>
<p></p><pre class="crayon-plain-tag">http://www.py4e.com/code3/mbox.txt
&gt;&gt;&gt; fhand = open('mbox.txt')
&gt;&gt;&gt; print(fhand)
&lt;_io.TextIOWrapper name='mbox.txt' mode='r' encoding='cp1252'&gt;</pre><p> </p>
<p>اگر عملیات open موفقیت‌آمیز باشد، سیستم عامل یک file handle یا «دستگیره‌ی فایل» باز می‌گرداند. دستگیره‌ی فایل، خودِ داده‌های موجود در فایل نیست، اما در عوض یک «دستگیره» است که ما می‌توانیم با استفاده از آن، داده‌ها را بخوانیم. اگر فایل درخواست‌شده وجود خارجی داشته باشد، شما یک دستگیره خواهید داشت و اگر مجوزهای لازم را در اختیار داشته باشید، فایل خوانده خواهد شد.</p>
<p><a href="https://ilola.ir/contents/data/2017/08/07-02.png"><img src="https://ilola.ir/contents/data/2017/08/07-02-1024x531.png" alt="دستگیره فایل" width="1024" height="531" class="aligncenter size-large wp-image-1629" /></a></p>
<p>اگر فایل وجود خارجی نداشته باشد، open با شکست روبرو شده و شما را به یک تریس‌بک مهمان خواهد کرد. در نهایت شما دستگیره، برای دسترسی به محتویات فایل، نخواهید داشت:</p>
<p></p><pre class="crayon-plain-tag">&gt;&gt;&gt; fhand = open('stuff.txt')
Traceback (most recent call last):
  File "", line 1, in 
FileNotFoundError: [Errno 2] No such file or directory: 'stuff.txt'</pre><p> </p>
<p>در ادامه ما از try و except برای مدیریت موقرانه این حالت استفاده خواهیم کرد. به این صورت وقتی تلاش کردیم که یک فایلی که وجود ندارد را باز کنیم، با تریس‌بکِ خشنِ پایتون چشم‌درچشم نشویم.</p>
<p>این نوشته تحت مجوز کرییتیو کامنز BY – NC و حمایت موسسه تحقیقاتی رامونا ارائه می‌شود. شما می‌توانید با توجه به مفاد این گواهی از آن استفاده کنید.</p>
]]></content:encoded>
			<wfw:commentRss>http://192.168.1.6/1628/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>پایتون برای همه &#124; 32 &#124; تجزیه تحلیل (پارس کردن) رشته‌ها و عملگر Format و تمرین‌ها</title>
		<link>http://192.168.1.6/1625/</link>
		<comments>http://192.168.1.6/1625/#respond</comments>
		<pubDate>Wed, 20 Sep 2017 07:04:42 +0000</pubDate>
		<dc:creator><![CDATA[Eman]]></dc:creator>
				<category><![CDATA[برنامه‌نویسی]]></category>

		<guid isPermaLink="false">https://ilola.ir/?p=1625</guid>
		<description><![CDATA[تجزیه تحلیل (پارس کردن) رشته‌ها احتمالاً برای شما هم زیاد پیش می‌آید که به داخل یک رشته نگاه کرده و به دنبال یک زیر-رشته بگردید. <a class="mh-excerpt-more" href="http://192.168.1.6/1625/" title="پایتون برای همه &#124; 32 &#124; تجزیه تحلیل (پارس کردن) رشته‌ها و عملگر Format و تمرین‌ها">[...]</a>]]></description>
				<content:encoded><![CDATA[<h2>تجزیه تحلیل (پارس کردن) رشته‌ها</h2>
<p>احتمالاً برای شما هم زیاد پیش می‌آید که به داخل یک رشته نگاه کرده و به دنبال یک زیر-رشته بگردید. مثلا فرض کنید که یک سری خط که به صورت زیر قالب‌بندی شده‌اند را داریم:</p><pre class="crayon-plain-tag">From stephen.marquard@uct.ac.za Sat Jan  5 09:14:16 2008</pre><p>حالا شاید بخواهیم که قسمت دوم آدرس را از هر خط جدا کرده و برداریم (در اینجا: uct.ac.za). ما می‌توانیم از متد find و روش قاچ زدن در پایتون، استفاده کنیم.</p><pre class="crayon-plain-tag">&gt;&gt;&gt; data = 'From stephen.marquard@uct.ac.za Sat Jan  5 09:14:16 2008'
&gt;&gt;&gt; atpos = data.find('@')
&gt;&gt;&gt; print(atpos)
21
&gt;&gt;&gt; sppos = data.find(' ',atpos)
&gt;&gt;&gt; print(sppos)
31
&gt;&gt;&gt; host = data[atpos+1:sppos]
&gt;&gt;&gt; print(host)
uct.ac.za
&gt;&gt;&gt;</pre><p>ما از یک نسخه از متد find که به ما اجازه مشخص کردن جایگاه کاراکتری را در رشته می‌دهد، استفاده کردیم؛ به این صورت find می‌داند که جستجو را از کجا شروع کند. زمانی که شروع به قاچ‌زدن کردیم، ما از کاراکتری که یکی از ‎@‎ جلوتر بود شروع کردیم. شاخص دوم که نشانگر پایانِ قاچ‌زدن است، کاراکتر فاصله بود که در مثال بالا با نام متغیر sppos مشخص است. حالا ما قاچ‌زدن را از کاراکتر بعد از ‎@‎ و تا کاراکتر فاصله (ولی نه شامل آن) انجام دادیم.</p>
<p>سند مرتبط به متد find را می‌توانید در این <a href="https://docs.python.org/3.5/library/stdtypes.html#string-methods" target="_blank" rel="noopener">لینک</a> زیر بخوانید.</p>
<h2>عملگر format / قالب / آرایش</h2>
<p>عملگر فرمت یا آرایش یعنی ‎%‎ به ما اجازه‌ی ساخت رشته‌ها و جابجا کردن بخشی از آن‌ها را با داده‌هایی که در متغیرها ذخیره شده است، می‌دهد. زمانی که ‎%‎ بر روی اعداد صحیح به کار گرفته می‌شود، عملگر پیمانه خوانده شده و کارکرد متفاوتی دارد. زمانی که اولین عملوند یک رشته باشد، ‎%‎ عملگر آرایش خواهد بود.</p>
<p>اولین عملوند فرمت‌استرینگ1 یا رشته چینش2 خوانده می‌شود و شامل تعداد یک یا بیشتر از فرمت‌سکوئنس3 یا «توالی چینش [حروف]» می‌شود. فرمت‌سکوئنس مشخص می‌کند که عملوند نظیر به نظیر چگونه قالب‌بندی یا آرایش شود. نتیجه‌ی حاصله یک رشته خواهد بود.</p>
<p>به عنوان مثال، فرمت‌سکوئنس &#8220;‎%d&#8221; به این معنیست که دومین عملوند بایستی که به عنوان یک عدد صحیح قالب‌بندی شود (در اینجا d اولین حرف decimal است).</p><pre class="crayon-plain-tag">&gt;&gt;&gt; camels = 42
&gt;&gt;&gt; '%d' % camels
'42'</pre><p>نتیجهْ رشته‌ای با مقدار ‎&#8221;42&#8243;‎ است. مراقب باشید که این ‎&#8221;42&#8243;‎ با عدد ‎42 متفاوت است چرا که اولی یک رشته است و دومی یک عدد صحیح.</p>
<p>یک فرمت‌سکوئنس، در هر جایی از یک رشته می‌تواند قرار بگیرد، در نتیجه می‌توانید مقداری را در درون یک جمله فرو کنید. به مثال زیر دقت کنید:</p><pre class="crayon-plain-tag">&gt;&gt;&gt; camels = 42
&gt;&gt;&gt; 'I have spotted %d camels.' % camels
'I have spotted 42 camels.'</pre><p>اگر بیش از یک فرمت‌سکوئنس در یک رشته وجود داشته باشد، دومین آرگیومنت بایستی یک تاپِل4 باشد. هر فرمت‌سکوئنس با عنصر موجود در تاپل به ترتیب تطبیق داده می‌شود.</p>
<p>مثال زیر از &#8220;‎%d&#8221; برای جایگذاری یک عدد صحیح و &#8220;‎%g&#8221; برای جایگذاری یک عدد اعشاری (نپرسید چرا) و &#8220;‎%s&#8221; برای جایگذاری یک رشته استفاده کرده است.</p><pre class="crayon-plain-tag">&gt;&gt;&gt; 'In %d years I have spotted %g %s.' % (3, 0.1, 'camels')
'In 3 years I have spotted 0.1 camels.'</pre><p>شماره‌ی عناصر در تاپل بایستی با شماره فرمت‌سکوئنس در رشته تطابق داشته باشد. مثلاً سومین فرمت‌سکوئنس با سومین عنصر موجود در تاپل پیوند می‌خورد. همچنین نوع عناصر بایستی که با فرمت‌سکوئنس مطابق باشد:</p><pre class="crayon-plain-tag">&gt;&gt;&gt; '%d %d %d' % (1, 2)
TypeError: not enough arguments for format string
&gt;&gt;&gt; '%d' % 'dollars'
TypeError: %d format: a number is required, not str</pre><p>در مثال اول، عناصر کافی برای عبارت وجود ندارد و در مثال دوم عملوند دوم با نوع اشتباهی نظیر به نظیر شده است.</p>
<p>عملگر قالب، عملگر قدرتمندی‌ست با این توضیح که استفاده از آن سخت است. اطلاعات بیشتر را می‌توانید از پیوند زیر بخوانید:</p>
<p><a href="https://docs.python.org/3.5/library/stdtypes.html#printf-style-string-formatting" target="_blank" rel="noopener">سند عملگر قالب</a></p>
<h2>اشکال‌زدایی</h2>
<p>مهارتی که لازم است در حین یادگیری برنامه‌نویسی بیاموزید، پرسش دائمی این سؤال از خود است: «چه مشکلی اینجا می‌تونه پیش بیاد؟» یا «چه کار یا کارهایی، کاربر نهایی می‌تونه انجام بده که برنامه‌ی &#8220;بی‌نقص&#8221; ما کرش کنه؟»</p>
<p>برای نمونه، به برنامه‌ای که ما برای نشان دادن حلقه‌ی while در فصل «تکرار» استفاده کردیم دقت کنید:</p><pre class="crayon-plain-tag">while True:
    line = input('&gt; ')
    if line[0] == '#':
        continue
    if line == 'done':
        break
    print(line)
print('Done!')

# Code: http://www.py4e.com/code3/copytildone2.py</pre><p>اگر کاربر هیچ ورودی وارد نکند و Enter را بزند چه اتفاقی می‌افتد:</p><pre class="crayon-plain-tag">&gt; hello there
hello there
&gt; # don't print this
&gt; print this!
print this!
&gt;
Traceback (most recent call last):
  File "copytildone.py", line 3, in 
    if line[0] == '#':
IndexError: string index out of range</pre><p>کد به خوبی کار می‌کند، مگر اینکه با یک خط خالی مواجه شود. در این صورت به این خاطر که کاراکتر صفرمی وجود ندارد، ما یک تریس‌بک دریافت می‌کنید.</p>
<p>دو راه‌حل برای حل این مشکل و امن کردن خط سوم – حتی اگر ورودی خالی باشد – وجود دارد.</p>
<p>اولین راه استفاده از متد startswith است که مقدار False را برای رشته‌ی خالی برمی‌گرداند:</p><pre class="crayon-plain-tag">if line.startswith('#'):</pre><p>دومین راه‌حل نوشتن یک گزاره‌ی if با استفاده از الگوی محافظ است. به این صورت که مطمئن شویم دومین عبارت منطقی تنها زمانی که حداقل یک کاراکتر در رشته وجود دارد بررسی می‌شود.</p><pre class="crayon-plain-tag">if len(line) &gt; 0 and line[0] == '#':</pre><p></p>
<h2>واژگان فصل</h2>
<p><strong>شمارنده / Counter:</strong><br />
متغیری که برای شمارش چیزی به کار می‌رود و معمولا در ابتدا با صفر مقداردهی می‌شود و سپس افزایش پیدا می‌کند.</p>
<p><strong>رشته خالی / Empty String:</strong><br />
رشته‌ای که کاراکتری نداشته و طول آن ‎0 است و توسط دو علامت نقل‌قول مشخص می‌شود.</p>
<p><strong>عملگر قالب یا آرایش / Format Operator:</strong><br />
یک عملگر، ‎%‎، که یک «چینش رشته/فرمت‌استرینگ» و یک تاپل را گرفته و سپس یک رشته که شامل عناصر آن تاپل می‌شود را می‌سازد؛ به صورتی که فرمت‌استرینگ تعیین‌کننده‌ی ترتیب قرار گیری تاپل در داخل رشته می‌شود.</p>
<p><strong>توالی چینش حروف / Format Sequence:</strong><br />
توالی‌ای از کاراکترها در یک فرمت‌استرینگ، مثل ‎%d، که نشان می‌دهد یک مقدار چطور بایستی شکل بگیرد.</p>
<p><strong>رشته چینش / Format String:</strong><br />
رشته‌ای که در کنار عملگر قالب مورد استفاده قرار می‌گیرد و شامل توالی حروف می‌شود.</p>
<p><strong>پرچم / Flag:</strong><br />
یک متغیر بولی که برای نشان دادن درست یا غلط بودن یک شرط مورد استفاده قرار می‌گیرد.</p>
<p><strong>احضار / Invocation:</strong><br />
یک گزاره که متدی را فراخوانی می‌کند.</p>
<p><strong>غیرقابل تغییر / Immutable:</strong><br />
زنجیره‌ای که آیتم‌های آن قابل گمارش نیستند. به عبارتی شما نمی‌توانید آیتم‌های موجود در آن را تغییر دهید و مقدار جدیدی را به آن‌ها اختصاص دهید.</p>
<p><strong>شاخص / Index:</strong><br />
یک مقدار صحیح برای انتخاب آیتمی در یک زنجیره، مانند یک کاراکتر در یک رشته.</p>
<p><strong>آیتم / Item:</strong><br />
یکی از مقادیر موجود در یک توالی.</p>
<p><strong>متد / Method:</strong><br />
یک تابع که با یک آبجکت در ارتباط است و توسط نشانه‌گذاری نقطه‌ای یا نماد نقطه فراخواهی می‌شود.</p>
<p><strong>آبجکت / Object:</strong><br />
چیزی که یک متغیر می‌تواند به آن ارجاع پیدا کند. فعلا می‌توانید از آبجکت و متغیر به جای هم استفاده کنید چون تا اینجا تقریبا معنای مشابهی دارند.</p>
<p><strong>جستجو / Search:</strong><br />
الگویی از پیمایش برای یافتن چیزی است که بعد از یافتن آن متوقف می‌شود.</p>
<p><strong>توالی یا زنجیره / Sequence:</strong><br />
یک مجموعه‌ی مرتب شده از یک دسته از مقدارهاست که هر مقدار توسط یک شاخص صحیح شناسایی می‌شود.</p>
<p><strong>قاچ یا قطعه / Slice:</strong><br />
قسمتی از یک رشته که توسط بازه‌ای از شاخص‌ها مشخص شده است.</p>
<p><strong>پیمایش / Traverse:</strong><br />
گردش کردن در بین آیتم‌های یک توالی، و انجام عملیات مشابه بر روی هر کدام از آن‌ها.</p>
<h2>تمرین‌ها</h2>
<p>تمرین ۵: کدِ پایتون زیر را بردارید:</p><pre class="crayon-plain-tag">str = 'X-DSPAM-Confidence:0.8475'</pre><p>با استفاده از find و قابلیت قاچ‌کردن رشته، قسمتی از رشته که بعد از دو نقطه آمده را جدا کرده و سپس با استفاده از تابع float آن قسمت جداشده را به یک عدد اعشاری تبدیل کنید.</p>
<p>تمرین ۶: اسناد متدهای رشته را از <a href="https://docs.python.org/3.5/library/stdtypes.html#string-methods" target="_blank" rel="noopener">این لینک</a> بخوانید.</p>
<p>برای اینکه بفهمید بعضی از آن‌ها چطور کار می‌کنند بهتر است که در عمل از این متدها استفاده کنید. متدهای strip و replace از جمله به‌دردبخورها به حساب می‌آیند.</p>
<p>سند، از چینشِ متن خاصی – که ممکن است شما را گیج کند – استفاده می‌کند. برای مثال در find(sub[, start[, end]])‎ قلاب‌ها نشان‌دهنده‌ی آرگیومنت‌های اختیاری‌اند. در نتیجه sub اجباری‌ست ولی start که در قلاب قرار دارد اختیاری‌ست. همچنین اگر start را مشخص کنید، end نیز می‌تواند به صورت اختیاری مورد استفاده قرار بگیرد.</p>
<p>این نوشته تحت مجوز کرییتیو کامنز BY – NC و حمایت موسسه تحقیقاتی رامونا ارائه می‌شود. شما می‌توانید با توجه به مفاد این گواهی از آن استفاده کنید.</p>
]]></content:encoded>
			<wfw:commentRss>http://192.168.1.6/1625/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>پایتون برای همه &#124; 31 &#124; آبجکت و متد</title>
		<link>http://192.168.1.6/1621/</link>
		<comments>http://192.168.1.6/1621/#respond</comments>
		<pubDate>Sat, 26 Aug 2017 06:23:41 +0000</pubDate>
		<dc:creator><![CDATA[Eman]]></dc:creator>
				<category><![CDATA[برنامه‌نویسی]]></category>

		<guid isPermaLink="false">https://ilola.ir/?p=1621</guid>
		<description><![CDATA[عملگر in کلمه‌ی in یک عملگر بولی است که دو رشته را می‌گیرد و True را اگر رشته‌ی اول به عنوان قسمتی از رشته‌ی دوم <a class="mh-excerpt-more" href="http://192.168.1.6/1621/" title="پایتون برای همه &#124; 31 &#124; آبجکت و متد">[...]</a>]]></description>
				<content:encoded><![CDATA[<h2>عملگر in</h2>
<p>کلمه‌ی in یک عملگر بولی است که دو رشته را می‌گیرد و True را اگر رشته‌ی اول به عنوان قسمتی از رشته‌ی دوم باشد، برمی‌گرداند.</p>
<p></p><pre class="crayon-plain-tag">&gt;&gt;&gt; 'a' in 'banana'
True
&gt;&gt;&gt; 'seed' in 'banana'
False</pre><p> </p>
<h2>مقایسه رشته</h2>
<p>عملگرهای مقایسه بر روی رشته‌ها نیز عمل می‌کنند. اگر می‌خواهید ببینید که دو رشته با هم برابرند:</p>
<p></p><pre class="crayon-plain-tag">if word == 'banana':
    print('All right, bananas.')</pre><p> </p>
<p>بقیه‌ی عملگرهای مقایسه برای مرتب کردن کلمات بر اساس الفبا می‌توانند کمک بزرگی به شما باشند:</p>
<p></p><pre class="crayon-plain-tag">if word &lt; 'banana':
    print('Your word,' + word + ', comes before banana.')
elif word &gt; 'banana':
    print('Your word,' + word + ', comes after banana.')
else:
    print('All right, bananas.')</pre><p> </p>
<p>رفتار مردم در مقایسه با پایتون در خصوص حروف بزرگ و کوچک متفاوت است. در پایتون تمام حروف بزرگ پیش از تمام حروف کوچک می‌آید:</p>
<p></p><pre class="crayon-plain-tag">Your word, Pineapple, comes before banana.</pre><p> </p>
<p>یک راه‌حل رایج برای این مساله استفاده از قالب استاندارد است. مثلا می‌توانید تمام حروف را به حروف کوچک تبدیل کنید و سپس عملیات را بر روی آن انجام دهید. </p>
<h2>متدهای رشته (string)</h2>
<p>رشته‌ها یک مثال از آبجکت‌های پایتون به شمار می‌روند. یک آبجکت (شئ) شامل داده و متدها می‌شود. متد، توابعی است که در آبجکت به صورت توکاری‌شده قرار داده شده‌اند و برای تمام نمونه‌های آن آبجکت در دسترسند.</p>
<p>پایتون یک تابعی با نام dir دارد که لیست متدهای موجود در یک آبجکت را به نمایش می‌گذارد. تابع type نوع یک آبجکت را نشان می‌‌دهد و تابع dir متدهای موجود در آن آبجکت را.</p>
<p></p><pre class="crayon-plain-tag">&gt;&gt;&gt; stuff = 'Hello world'
&gt;&gt;&gt; type(stuff)
&lt;class 'str'&gt;
&gt;&gt;&gt; dir(stuff)
['capitalize', 'casefold', 'center', 'count', 'encode',
'endswith', 'expandtabs', 'find', 'format', 'format_map',
'index', 'isalnum', 'isalpha', 'isdecimal', 'isdigit',
'isidentifier', 'islower', 'isnumeric', 'isprintable',
'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower',
'lstrip', 'maketrans', 'partition', 'replace', 'rfind',
'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip',
'split', 'splitlines', 'startswith', 'strip', 'swapcase',
'title', 'translate', 'upper', 'zfill']
&gt;&gt;&gt; help(str.capitalize)
Help on method_descriptor:

capitalize(...)
    S.capitalize() -&gt; str

    Return a capitalized version of S, i.e. make the first character
    have upper case and the rest lower case.
&gt;&gt;&gt;</pre><p> </p>
<p> تابع dir لیست متدها را نشان می‌دهد و در کنارش تابع help اطلاعات و اسناد ساده‌ای از یک متد را به نمایش می‌گذارد. اطلاعات بهتر از متدهای رشته را می‌توانید از اینجا بخونید:</p>
<p><a href="https://docs.python.org/3.5/library/stdtypes.html#string-methods" target="_blank">لینک سند</a></p>
<p>فراخوانی یک متد، به مانند فراخوانی یک تابع است، یعنی متد هم آرگیومنت را می‌گیرد و مقداری را برمی‌گرداند؛ ولی متنِ این فراخوانی متفاوت است. برای فراخوانی متد، نامِ آن را به نام متغیر با یک نقطه بینشان می‌چسبانیم.</p>
<p>به عنوان مثال متد upper یک رشته را می‌گیرد و رشته‌ای جدید که تمام حروفش بزرگ است را برمی‌گرداند.</p>
<p>به جای استفاده از متن تابع که به صورت upper(word)‎ است، ما از متن مخصوص متد یعنی word.upper()‎ استفاده می‌کنیم.</p>
<p></p><pre class="crayon-plain-tag">&gt;&gt;&gt; word = 'banana'
&gt;&gt;&gt; new_word = word.upper()
&gt;&gt;&gt; print(new_word)
BANANA</pre><p> </p>
<p>این قالب که به آن «نمادِ نقطه» می‌گوییم، نام متد، upper، و نام رشته را مشخص کرده و متد را بر روی آن (در مثال ما متغیر word) اعمال می‌کند. پرانتزهای خالی به این معنی‌ست که این متد هیچ آرگیومنتی را دریافت نمی‌کند.</p>
<p>فراخوانی یک متد، invocation یا «احضار» خوانده می‌شود. در این مثال، ما می‌گوییم که upper را بر روی word احضار کردیم.</p>
<p>برای مثال، یک متد رشته به اسم find وجود دارد که جایگاه یک رشته را در یک رشته‌ی دیگر جستجو می‌کند:</p>
<p></p><pre class="crayon-plain-tag">&gt;&gt;&gt; word = 'banana'
&gt;&gt;&gt; index = word.find('a')
&gt;&gt;&gt; print(index)
1</pre><p> </p>
<p>در این نمونه، ما find را بر روی word احضار کرده و حرفی که در پی آن بودیم را به صورت پارامتر برایش فرستادیم.</p>
<p>متد find قادر به پیدا کردنِ زیررشته‌ها به مانند کاراکترهاست:</p>
<p></p><pre class="crayon-plain-tag">&gt;&gt;&gt; word.find('na')
2</pre><p> </p>
<p>این متد می‌تواند آرگیومنت دوم را نیز دریافت کرده تا بداند که جستجو را از چه مکانی شروع کند:</p>
<p></p><pre class="crayon-plain-tag">&gt;&gt;&gt; word.find('na', 3)
4</pre><p> </p>
<p>یک کار شایع و رایج از بین بردن فاصله‌های خالی (فاصله یا tab یا خطوط جدید) از ابتدا و انتهای یک رشته با استفاده از متد strip است:</p>
<p></p><pre class="crayon-plain-tag">&gt;&gt;&gt; line = '  Here we go  '
&gt;&gt;&gt; line.strip()
'Here we go'</pre><p> </p>
<p>برخی متدها مثل startswith مقدارهای بولی را برمی‌گردانند:</p>
<p></p><pre class="crayon-plain-tag">&gt;&gt;&gt; line = 'Have a nice day'
&gt;&gt;&gt; line.startswith('Have')
True
&gt;&gt;&gt; line.startswith('h')
False</pre><p> </p>
<p>خواهید فهمید که متد startswith به بزرگی و کوچکی حروف حساس است، به همین خاطر شاید بد نباشد که کل یک خط را گرفته و حروفش را به حروف کوچک تبدیل کرده و سپس بررسی را بر روی آن انجام دهید:</p>
<p></p><pre class="crayon-plain-tag">&gt;&gt;&gt; line = 'Have a nice day'
&gt;&gt;&gt; line.startswith('h')
False
&gt;&gt;&gt; line.lower()
'have a nice day'
&gt;&gt;&gt; line.lower().startswith('h')
True</pre><p> </p>
<p>در مثال آخر، متد lower احضار شده و سپس از متد startswith استفاده کرده‌ایم. به این صورت متد startswith بر روی رشته‌ی جدید که تمام حروفش کوچک است عملیات را انجام می‌دهد. اگر مراقب ترتیبِ متدها باشید، حتی می‌توانید چند متد را به صورت ترکیبی در تنها یک عبارت احضار کنید:</p>
<p></p><pre class="crayon-plain-tag">&gt;&gt;&gt; line = 'Have a nice day'
&gt;&gt;&gt; line.startswith('h')
False
&gt;&gt;&gt; line.lower().startswith('h')
True
&gt;&gt;&gt;</pre><p> </p>
<p>تمرین ۴: یک متد رشته‌ به نام count وجود دارد که شبیه به تابعی که در مثال قبل نوشتیم عمل می‌کند. اسناد مرتبط با این متد را از لینک زیر بخوانید و سپس یک احضاریه بنویسد که تعداد تکرارِ حرف a در banana را برگرداند.</p>
<p><a href="https://docs.python.org/3.5/library/stdtypes.html#string-methods" target="_blank">لینک سند</a></p>
<p>این نوشته تحت مجوز کرییتیو کامنز BY – NC و حمایت موسسه تحقیقاتی رامونا ارائه می‌شود. شما می‌توانید با توجه به مفاد این گواهی از آن استفاده کنید.</p>
]]></content:encoded>
			<wfw:commentRss>http://192.168.1.6/1621/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>پایتون برای همه &#124; 30 &#124; پیمایش در رشته &#124; تغییرناپذیری رشته‌ها &#124; حلقه‌زنی و شمارش</title>
		<link>http://192.168.1.6/1611/</link>
		<comments>http://192.168.1.6/1611/#respond</comments>
		<pubDate>Wed, 09 Aug 2017 06:24:47 +0000</pubDate>
		<dc:creator><![CDATA[Eman]]></dc:creator>
				<category><![CDATA[برنامه‌نویسی]]></category>

		<guid isPermaLink="false">https://ilola.ir/?p=1611</guid>
		<description><![CDATA[بسیاری از محاسبات، با استفاده از پردازش تک‌تک کاراکترهای موجود در یک رشته صورت می‌پذیرد. اغلب از ابتدا آغاز می‌شود، هر کاراکتر را به صورت <a class="mh-excerpt-more" href="http://192.168.1.6/1611/" title="پایتون برای همه &#124; 30 &#124; پیمایش در رشته &#124; تغییرناپذیری رشته‌ها &#124; حلقه‌زنی و شمارش">[...]</a>]]></description>
				<content:encoded><![CDATA[<p>بسیاری از محاسبات، با استفاده از پردازش تک‌تک کاراکترهای موجود در یک رشته صورت می‌پذیرد. اغلب از ابتدا آغاز می‌شود، هر کاراکتر را به صورت جداگانه انتخاب می‌کند، کاری بر روی آن انجام می‌دهد و به سراغ کاراکتر بعدی تا انتهای رشته می‌رود. به این الگوی پردازشی، «پیمایش» می‌گویند. یکی از راه‌های نوشتن یک پیمایش استفاده از حلقه while است:</p>
<p></p><pre class="crayon-plain-tag">index = 0
while index &lt; len(fruit):
    letter = fruit[index]
    print(letter)
    index = index + 1</pre><p> </p>
<p>این حلقه، پیمایشی را در رشته آغاز کرده و هر حرف را به صورت مستقل در یک خط به نمایش می‌گذارد. شرطِ حلقه index &lt; len(fruit)‎ است، در نتیجه به محضی که index مساوی با طول رشته شد، شرط غلط از آب در آمده و بدنه‌ی حلقه اجرا نخواهد شد. آخرین کاراکتری که عملیات در این حلقه بر روی آن انجام می‌شود، با شاخص len(fruit)-1 خواهد بود که خب آخرین کاراکتر رشته نیز محسوب می‌شود.</p>
<p>تمرین ۱: یک حلقه while بنویسید که از آخرین کاراکتر موجود در یک رشته شروع کرده و بالعکسِ حلقه‌ی بالا، به سمت ابتدای حلقه حرکت کند و هر حرف را در یک خط جداگانه به مانند حلقه‌ی بالا چاپ می‌کند. با این تفاوت که چاپ کردنِ حروف از حرف آخر شروع شود و به اول برسد.</p>
<p>یک راه دیگر برای نوشتن یک پیمایش استفاده از حلقه for است:</p>
<p></p><pre class="crayon-plain-tag">for char in fruit:
    print(char)</pre><p> </p>
<p>هر باری که حلقه اجرا می‌شود، کاراکتر بعدی به متغیر char نسبت داده خواهد شد. این حلقه تا زمانی که کاراکتری باقی نمانده باشد، ادامه پیدا می‌کند.</p>
<h2>قاچ‌هایی از رشته</h2>
<p>یک بخش از یک رشته را «قاچ» یا «قطعه» می‌گوییم. انتخاب یک قطعه از رشته، مشابه با انتخاب یک کاراکتر است. به مثال زیر نگاه کنید:</p>
<p></p><pre class="crayon-plain-tag">&gt;&gt;&gt; s = 'Monty Python'
&gt;&gt;&gt; print(s[0:5])
Monty
&gt;&gt;&gt; print(s[6:12])
Python</pre><p> </p>
<p>عملگر، قسمتی از رشته که از کاراکتر nام شروع شده و به کاراکتر mام می‌رسد را برمی‌گدارند. با این قاعده که حاصلْ شاملِ کاراکتر nام می‌شود، ولی شامل کاراکتر mام نخواهد شد.</p>
<p>اگر شما شاخص اول (قبل از دو نقطه) را از قلم بیندازید، قطعه از ابتدای رشته شروع خواهد شد. اگر شاخص دوم (بعد از دو نقطه) را از قلم بیندازید، قطعه تا پایان رشته خواهد بود:</p>
<p></p><pre class="crayon-plain-tag">&gt;&gt;&gt; fruit = 'banana'
&gt;&gt;&gt; fruit[:3]
'ban'
&gt;&gt;&gt; fruit[3:]
'ana'</pre><p> </p>
<p>اگر اولین شاخص، بزرگتر و یا برابر با شاخص دوم بود، حاصلْ یک رشته‌ی خالی می‌شود که با دو علامت نقل قول مشخص خواهد شد:</p>
<p></p><pre class="crayon-plain-tag">&gt;&gt;&gt; fruit = 'banana'
&gt;&gt;&gt; fruit[3:3]
''</pre><p> </p>
<p>یک رشته‌ی خالی، شامل هیچ کاراکتری نشده و طول آن ‎0 خواهد بود، ولی در سایر موارد شبیه به یک رشته‌ی معمولی می‌باشد.</p>
<p>تمرین ۲: فرض کنید که fruit یک رشته است. fruit[:]‎ چه معنی‌ای را می‌دهد؟</p>
<h2>رشته‌ها قابل تغییر نیستند</h2>
<p>شاید وسوسه شده باشید که با استفاده از عملگر گمارش (=) یک کاراکتر در رشته را درآورده و تغییر دهید. مثلا:</p>
<p></p><pre class="crayon-plain-tag">&gt;&gt;&gt; greeting = 'Hello, world!'
&gt;&gt;&gt; greeting[0] = 'J'
TypeError: 'str' object does not support item assignment</pre><p> </p>
<p>آبجکت در این حالت یک رشته است و آیتم، کاراکتری‌ست که شما می‌خواهید آن را به رشته اختصاص دهید. در اینجا آبجکت مثل یک مقدار است؛ ولی در آینده معنای دقیق‌تری از آن را برای‌تان خواهیم گفت. یک آیتم، یکی از مقادیر موجود در یک زنجیر به حساب می‌آید.</p>
<p>دلیل خطای مثال بالا، این است که رشته‌ها تغییر ناپذیرند، به این معنی که شما یک رشته‌ی موجود را نمی‌توانید تغییر دهید. بهترین کاری که می‌توانید انجام دهید، ساخت یک رشته‌ی جدید با استفاده از رشته‌ی قبلی و جایگزینی کاراکتر با بهره‌گیری از شاخص‌هاست:</p>
<p></p><pre class="crayon-plain-tag">&gt;&gt;&gt; greeting = 'Hello, world!'
&gt;&gt;&gt; new_greeting = 'J' + greeting[1:]
&gt;&gt;&gt; print(new_greeting)
Jello, world!</pre><p> </p>
<p>در این مثال ما حرف اول را با استفاده از قطعه کردن greeting و چسباندن یک کاراکتر به آن، تغییر دادیم. به یاد داشته باشید که رشته‌ی اصلی همان Hello, World سابق است.</p>
<h2>حلقه‌زنی و شمارش</h2>
<p>برنامه‌ی زیر، تعداد دفعالتی که حرف a در رشته ظاهر شده را حساب می‌کند:</p>
<p></p><pre class="crayon-plain-tag">word = 'banana'
count = 0
for letter in word:
    if letter == 'a':
        count = count + 1
print(count)</pre><p> </p>
<p>در این برنامه ما الگوی دیگری از محاسبه، به اسم «شمارش» را به شما نشان دادیم. متغیر count با 0‎ مقداردهی اولیه شده و سپس هر بار که a در رشته پدیدار شد، یک عدد به آن اضافه گردید. زمانی که برنامه از حلقه خارج می‌شود، count حاوی نتیجه‌ای از تعداد aهای موجود در رشته خواهد بود.</p>
<p>تمرین ۳: این کد را در تابعی به اسم count قرار دهید که دو آرگیومنت دریافت می‌کند. آرگیومنت‌ها یکی رشته و دیگری حرفی که قرار است تعدادِ تکرارش را تابع پیدا کند و برگرداند.</p>
<p>این نوشته تحت مجوز کرییتیو کامنز BY – NC و حمایت موسسه تحقیقاتی رامونا ارائه می‌شود. شما می‌توانید با توجه به مفاد این گواهی از آن استفاده کنید.</p>
]]></content:encoded>
			<wfw:commentRss>http://192.168.1.6/1611/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>پایتون برای همه &#124; 29 &#124; رشته و طول آن‌ها</title>
		<link>http://192.168.1.6/1604/</link>
		<comments>http://192.168.1.6/1604/#comments</comments>
		<pubDate>Tue, 08 Aug 2017 03:09:30 +0000</pubDate>
		<dc:creator><![CDATA[Eman]]></dc:creator>
				<category><![CDATA[برنامه‌نویسی]]></category>

		<guid isPermaLink="false">https://ilola.ir/?p=1604</guid>
		<description><![CDATA[رشته چیست؟ یک رشته، زنجیره‌ای از کاراکترهاست. شما می‌توانید با استفاده از عملگر قلاب به هر کاراکتر در آنِ واحد دسترسی داشته باشید: [crayon-5bbd1bd2483ba659281296/] گزاره‌ی <a class="mh-excerpt-more" href="http://192.168.1.6/1604/" title="پایتون برای همه &#124; 29 &#124; رشته و طول آن‌ها">[...]</a>]]></description>
				<content:encoded><![CDATA[<h2>رشته چیست؟</h2>
<p>یک رشته، زنجیره‌ای از کاراکترهاست. شما می‌توانید با استفاده از عملگر قلاب به هر کاراکتر در آنِ واحد دسترسی داشته باشید:</p>
<p></p><pre class="crayon-plain-tag">&gt;&gt;&gt; fruit = 'banana'
&gt;&gt;&gt; letter = fruit[1]</pre><p> </p>
<p>گزاره‌ی دوم، کاراکتری که در موقعیت ‎1 از متغیر fruit قرار دارد را بیرون می‌کشد و آن را به متغیر letter نسبت می‌دهد.</p>
<p>عبارت داخل براکت‌ها را ایندکس یا شاخص می‌گوییم. شاخص نشان می‌دهد که کدام کاراکتر در سلسله‌ی موجود را می‌خواهید. ولی شاید انتظار شما از مقدار موجود در letter چیز دیگری باشد:</p>
<p></p><pre class="crayon-plain-tag">&gt;&gt;&gt; print(letter)
a</pre><p> </p>
<p>به صورت شهودی اولین کاراکتر موجود در رشته banana حرف b است، و نه a. ولی چرا شاخص ‎1 حرف a را نشان می‌دهد؟ در پایتون، شاخص از ابتدای یک رشته شروع و اولین حرف از رشته با شاخص ‎0 مشخص می‌شود.</p>
<p></p><pre class="crayon-plain-tag">&gt;&gt;&gt; letter = fruit[0]
&gt;&gt;&gt; print(letter)
b</pre><p> </p>
<p>در نتیجه b صفرمین حرف از رشته banana به حساب می‌آید و a یکمین و n دومین و به همین ترتیب.</p>
<p>شما می‌توانید از هر عبارتی، شامل متغیرها و عملگرها، به عنوان شاخص استفاده کنید، با این استثنا که مقدار شاخص بایستی یک عدد صحیح باشد وگرنه شما چیزی شبیه به این خطا را دریافت می‌کنید:</p>
<p></p><pre class="crayon-plain-tag">&gt;&gt;&gt; letter = fruit[1.5]
TypeError: string indices must be integers</pre><p> </p>
<h2>دریافت طول یک رشته با استفاده از len</h2>
<p>یک تابع توکاری شده با اسم len در پایتون وجود دارد که مقدار عددیِ تعداد کاراکترهای موجود در یک استرینگ را برمی‌گرداند:</p>
<p></p><pre class="crayon-plain-tag">&gt;&gt;&gt; fruit = 'banana'
&gt;&gt;&gt; len(fruit)
6</pre><p> </p>
<p>با استفاده از تابع len چطور می‌شود آخرین کاراکتر یک رشته را استخراج کرد؟ شاید بخواهید که از آن به این صورت استفاده کنید:</p>
<p></p><pre class="crayon-plain-tag">&gt;&gt;&gt; length = len(fruit)
&gt;&gt;&gt; last = fruit[length]
IndexError: string index out of range</pre><p> </p>
<p>ولی دلیل اینکه خطای IndexError گرفتیم چیست؟ حرفی با شاخص ‎6 در رشته banana وجود ندارد. از آنجایی که پایتون شمارش کاراکترهای رشته را با عدد ‎0 آغاز می‌کند، ما در این رشته شاخص‌های ‎0 تا ‎5 را داریم. به عبارتی برای دریافت آخرین کاراکتر از یک رشته، بایستی عدد یک را از اندازه‌ی طول آن رشته کسر کنیم:</p>
<p></p><pre class="crayon-plain-tag">&gt;&gt;&gt; last = fruit[length-1]
&gt;&gt;&gt; print(last)
a</pre><p> </p>
<p>همچنین می‌توانید از شاخص‌های منفی به منظور شمارش از آخر به اول استفاده کنید. عبارت fruit[-1]‎ آخرین حرف و عبارت fruit[-2]‎ حرف یکی مانده به آخر را استخراج می‌کند.</p>
<p>این نوشته تحت مجوز کرییتیو کامنز BY – NC و حمایت موسسه تحقیقاتی رامونا ارائه می‌شود. شما می‌توانید با توجه به مفاد این گواهی از آن استفاده کنید.</p>
]]></content:encoded>
			<wfw:commentRss>http://192.168.1.6/1604/feed/</wfw:commentRss>
		<slash:comments>2</slash:comments>
		</item>
		<item>
		<title>پایتون برای همه &#124; 28 &#124; تعریف حلقه‌ها با for &#124; واژگان فصل پنجم</title>
		<link>http://192.168.1.6/1597/</link>
		<comments>http://192.168.1.6/1597/#respond</comments>
		<pubDate>Thu, 03 Aug 2017 09:09:23 +0000</pubDate>
		<dc:creator><![CDATA[Eman]]></dc:creator>
				<category><![CDATA[برنامه‌نویسی]]></category>
		<category><![CDATA[for]]></category>

		<guid isPermaLink="false">https://ilola.ir/?p=1597</guid>
		<description><![CDATA[تعریف حلقه‌ها با for گاهی لازم است که بین دسته‌ای و محتویاتش دور بزنیم؛ مثلا بین لیستی از کلمه‌ها، یا خطوط در یک فایل، و <a class="mh-excerpt-more" href="http://192.168.1.6/1597/" title="پایتون برای همه &#124; 28 &#124; تعریف حلقه‌ها با for &#124; واژگان فصل پنجم">[...]</a>]]></description>
				<content:encoded><![CDATA[<h2>تعریف حلقه‌ها با for</h2>
<p>گاهی لازم است که بین دسته‌ای و محتویاتش دور بزنیم؛ مثلا بین لیستی از کلمه‌ها، یا خطوط در یک فایل، و یا شماره‌ها در یک فهرست. زمانی که لیستی از چیزی‌هایی داریم که لازم است بین‌شان بگردیم، ما از یک حلقه‌ی معین با استفاده از گزاره‌ی for بهره می‌بریم. چرا حلقه‌ «معین»؟ اگر یادتان باشد ما از گزاره‌ی while برای حلقه‌های نامعین استفاده می‌کردیم، چرا که حلقه while به سادگی تا زمانی که شرطِ اجرای آن «غلط» شود، تکرار می‌شود، ولی for در بین یک دسته‌ی «مشخص» و «معین» از چیزها حلقه می‌زند. به عبارتی آنقدر این حلقه را تکرار می‌کند که بازه‌ی مورد نظر در لیست را گشته باشد.</p>
<p><a href="https://www.ilola.ir/contents/data/2017/07/d8a8d8a7-for.jpg"><img class="aligncenter size-full wp-image-1599" src="https://www.ilola.ir/contents/data/2017/07/d8a8d8a7-for.jpg" alt="حلقه‌ها با for" width="678" height="509" /></a></p>
<p>متن یا سینتکس حلقه‌ی for مشابه با حلقه‌ی while است. به صورت کلی ما گزاره‌ی for و بدنه‌ی آن حلقه را با یک تورفتگی داریم:</p><pre class="crayon-plain-tag">friends = ['Joseph', 'Glenn', 'Sally']
for friend in friends:
    print('Happy New Year:', friend)
print('Done!')</pre><p>مثال بالا را در نظر بگیرید. در زبان پایتونی متغیر friends یک لیستی‌ست که شامل سه رشته می‌شود. حلقه‌ی for بین این لیست دور زده و بدنه‌ی حلقه را برای هر کدام از این سه رشته به صورت جداگانه اجرا می‌کند. در زیر خروجی برنامه‌ی بالا را مشاهده کنید:</p><pre class="crayon-plain-tag">Happy New Year: Joseph
Happy New Year: Glenn
Happy New Year: Sally
Done!</pre><p>ترجمه‌ی تحت‌الفظی while دقیقا همان چیزی بود که در پایتون مورد استفاده قرار می‌گرفت، ولی برای حلقه‌ی for اوضاع فرق می‌کند. بیایید حلقه‌ی مثال قبل را با هم به زبان آدمیزاد شرح دهیم: «گزاره‌های موجود در بدنه‌ی حلقه را برای هر کدام از دوستان موجود در لیست friends اجرا کن».</p>
<p>در کد مربوط به حلقه‌ی for کلمه‌های for و in کلمات رزرو شده‌اند و کلمات friend و friends متغیراند:</p><pre class="crayon-plain-tag">for friend in friends:
    print('Happy New Year:', friend)</pre><p>در این موردِ خاص، friend «متغیر تکرار» برای حلقه‌ی for محسوب می‌شود. متغیر friend در هر تکرار تغییر کرده و حلقه for را تا انتها کنترل می‌کند. به این صورت که با رسیدن متغیر به آخرین آیتم موجود در لیست، حلقه پایان می‌پذیرد. در مثال بالا، متغیر تکرار که همان friend باشد، پشت سر هم و به ترتیب سه رشته‌ی موجود در متغیر friends را در حلقه اجرا می‌کند.</p>
<h2>الگوی حلقه</h2>
<p>اغلب ما از حلقه‌ی for یا while استفاده کرده تا بر روی لیستی از آیتم‌ها یا محتوای یک فایل کار کنیم. مانند زمانی که به دنبال بزرگترین یا کوچکترین مقدار در داده‌ای که اسکن کرده‌ایم می‌باشیم.</p>
<p>به طور کلی، حلقه‌ها از سه جزء تشکیل شده‌اند:</p>
<ul>تعریف یک یا چند مقدار، قبل از شروع حلقه</ul>
<ul>اجرای محاسبات بر روی هر کدام از آیتم‌ها، و تغییر احتمالی متغیرهای موجود در بدنه‌ی حلقه</ul>
<ul>بررسی نتایج متغیرها زمانی که حلقه به پایان رسید</ul>
<p>در ادامه ما لیستی از شماره‌ها را – برای نشان دادن مفهوم و ساختار الگوی حلقه‌های رایج – برایتان آورده‌ایم.</p>
<h2>حلقه‌هایی که می‌شمارند و جمع می‌زنند</h2>
<p>برای نمونه، اگر قرار باشد شماره‌ی آیتم‌های موجود در یک لیست را بشماریم، ما از حلقه‌ی for استفاده می‌کنیم:</p><pre class="crayon-plain-tag">count = 0
for itervar in [3, 41, 12, 9, 74, 15]:
    count = count + 1
print('Count: ', count)</pre><p>قبل از اینکه حلقه شروع شود، مقدار متغیر count را صفر قرار می‌دهیم. سپس یک حلقه for می‌نویسیم. این حلقه تک‌تک آیتم‌های لیست را دور زده و به ازای هر کدام از آن‌ها یک بار گزاره‌ی موجود در بدنه را اجرا می‌کند. نامِ متغیر تکرار itervar است که کنترل حلقه را در دست دارد.</p>
<p>در بدنه‌ی حلقه ما عدد یک را به مقدار فعلی متغیر count به ازای هر کدام از مقادیر موجود در لیست اضافه می‌کنیم. زمانی که حلقه اجرا می‌شود، مقدار count برابر با آخرین مقداری‌ست که داشته است. مثلا در اجرای اول count برابر با صفر است ولی در تکرار دوم حلقه با توجه به اجرای اول، برابر با یک است که با توجه به گزاره‌ی موجود در بدنه‌ی حلقه به دو تبدیل می‌شود. به همین ترتیب با هر بار اجرای حلقه، مقدار count یک عدد افزایش پیدا می‌کند.</p>
<p>در نهایت مقدار count برابر با مجموع تعداد آیتم‌های موجود در لیست خواهد بود. این حلقه، خروجی خاصی را چاپ نمی‌کند، ولی مقداری را در نهایت به count اختصاص می‌دهد که هدف ما از ایجاد و ساخت آن حلقه بوده است.</p>
<p>در مثال زیر حلقه‌ای را داریم که مجموع اعداد موجود در لیست را محاسبه کرده و سپس چاپ می‌کند:</p><pre class="crayon-plain-tag">total = 0
for itervar in [3, 41, 12, 9, 74, 15]:
    total = total + itervar
print('Total: ', total)</pre><p>در این حلقه ما از متغیر تکرار استفاده کرده‌ایم. به جای اضافه کردن عدد یک به count – به مانند مثال قبل – ما عدد موجود در لیست (۳،۴۱، ۱۲، ۹ و…) را به مقدار کل، در حین اجرای آن تکرار اضافه نموده‌ایم. به عبارتی متغیر total حاوی مقداری برابر با جمع مقادیر تا آنجای کار می‌شود. قبل از اینکه حلقه شروع شود مقدار total صفر بود، چرا که هنوز مقدار اختصاص داده شده اولیه را در خود داشت و عملیاتی بر روی آن صورت نگرفته بود. در حین اجرای حلقه، مقدار total برابر با جمع مجموع مقدارهای موجود در لیست می‌شود و در پایان، مقدار total برابر با جمع تمامی مقادیر موجود در لیست خواهد بود.</p>
<p>همینطور که حلقه اجرا می‌شود، total جمع عناصر موجود در معادله را حساب می‌کند؛ یک متغیر که به این صورت مورد استفاده قرار می‌گیرد، accumulator یا انباشتگر خوانده می‌شود.<br />
نه حلقه‌ی شمارش و نه حلقه‌ی انباشتگر، در آینده به کار شما نخواهند آمد چرا که توابع توکاری‌شده‌ای به اسم‌های len()‎ و sum()‎ به ترتیب شماره‌ی آیتم‌ها، و جمع آیتم‌های موجود در یک لیست را به ما می‌دهند و شما نیاز به حلقه‌های فوق ندارید.</p>
<h2>حلقه برای یافتن مقدار بیشینه و کمینه</h2>
<p>برای پیدا کردن بزرگترین مقدار در یک لیست یا سلسله‌ای از اعداد ما حلقه‌ی زیر را ساخته‌ایم:</p><pre class="crayon-plain-tag">largest = None
print('Before:', largest)
for itervar in [3, 41, 12, 9, 74, 15]:
    if largest is None or itervar &gt; largest :
        largest = itervar
    print('Loop:', itervar, largest)
print('Largest:', largest)</pre><p>زمانی که برنامه اجرا می‌شود، خروجی زیر ظاهر خواهد شد:</p><pre class="crayon-plain-tag">Before: None
Loop: 3 3
Loop: 41 41
Loop: 12 41
Loop: 9 41
Loop: 74 74
Loop: 15 74
Largest: 74</pre><p>متغیر largest عبارت است از بزرگترین مقداری که تا اینجای کار به آن رسیده‌ایم. قبل از حلقه، ما مقدار largest را None قرار می‌دهیم. None یک مقدار ویژه‌ی غیرقابل تغییر است که می‌تواند به متغیرها اختصاص داده شود. این مقدار می‌گوید که متغیر «خالی» است.</p>
<p>قبل از شروع حلقه، بزرگترین مقداری که ما تا اینجای کار با توجه به جریان اجرا دیده‌ایم، None است. در حقیقت ما مقدار دیگری غیر از None را ندیده‌ایم. در خروجی بالا مشخص است که درست زمانیکه حلقه اجرا می‌شود، مقدار ۳ جایگزین مقدار اولیه‌ی متغیر largest می‌شود.</p>
<p>بعد از اولین تکرار، largest دیگر None نیست در نتیجه قسمت دوم عبارت منطقیِ ترکیبی – که مقایسه‌ی itervar &gt; largest را بررسی می‌کند – تنها زمانی درست از آب در می‌آید که به عددی بزرگتر از مقدار فعلی largest برخورد کند. وقتی ما در جریان اجرا به مقداری بزرگتر از largest برخورد می‌کنیم، مقدار largest تغییر کرده و آن مقدار جدید را به خود می‌گیرد. در مثال بالا می‌بینید که مقدار largest از ۳ به ۴۱ و سپس به ۷۴ تغییر پیدا کرد.</p>
<p>در پایان حلقه، ما یک به یک مقادیر را بررسی کرده‌ایم. largest حاوی بزرگترین مقدار موجود در لیست خواهد بود.</p>
<p>برای محاسبه‌ی کمترین مقدار موجود در لیست، کد قبلی تنها یک تغییر کوچک می‌کند:</p><pre class="crayon-plain-tag">smallest = None
print('Before:', smallest)
for itervar in [3, 41, 12, 9, 74, 15]:
    if smallest is None or itervar &lt; smallest:
        smallest = itervar
    print('Loop:', itervar, smallest)
print('Smallest:', smallest)</pre><p>به شکل مشابه smallest حاوی کوچکترین عددِ در جریان اجراست. زمانی که حلقه پایان می‌پذیرد، این متغیر حاوی کوچکترین عدد کل لیست خواهد بود.</p>
<p>به مانند شمارش و انباشتگر، توابع توکاری شده‌ای در پایتون با نام‌های max()‎ و min()‎ وجود دارد که به ترتیب بزرگترین و کوچکترین مقدار یک لیست را برمی‌گردانند.<br />
کد زیر یک نسخه‌ی ساده شده از تابع توکاری شده‌ی min()‎ در پایتون است:</p><pre class="crayon-plain-tag">def min(values):
    smallest = None
    for value in values:
        if smallest is None or value &lt; smallest:
            smallest = value
    return smallest</pre><p>تابع بالا، همان کد مربوط به محاسبه‌ی کوچکترین عدد بود که گزاره‌های print آن حذف شده است. اکنون این تابع کاری را که تابع توکاری شده python برای تشخیص کوچکترین عدد موجود در لیست، انجام می‌دهد را اجرایی می‌کند.</p>
<h2>اشکال‌زدایی</h2>
<p>به محضی که شروع به نوشتن برنامه‌های بزرگتر می‌کنید، تازه می‌بینید که گاهی اشکال‌زدایی زمان بیشتری از نوشتن خودِ کد از شما می‌گیرد. کدهای بیشتر، به معنی احتمالِ بیشترِ خطا و احتمال مخفی شدن باگ‌های بیشتر در برنامه است.</p>
<p>یکی از راه‌های صرفه‌جویی در زمان اشکال‌زدایی استفاده از تکنیک دو نیم کردن است. به عنوان مثال فرض کنید که ۱۰۰ خط کد دارید. اگر قرار باشد برای بررسی کد، خط به خط جلو بروید برای بررسیِ کاملِ کد، شما صد مرحله در پیش رو خواهید داشت.</p>
<p>حالا روش دیگری را استفاده می‌کنیم. شما ابتدا مساله را به نصف می‌شکنید. به وسط برنامه یا یک مکان منطقی در همان حوالی می‌روید و یک مقدار میانی را با استفاده از گزاره‌ی print چاپ می‌کنید. سپس برنامه را اجرا می‌کنید.</p>
<p>با بررسی خروجی گزاره print بررسی می‌کنید که مشکل از نیمه‌ی اول کد بوده یا خیر. چگونه؟ اگه مقدار میانی یک میزانِ اشتباه را برگرداند، خب مشکل از بخش اول کد است.</p>
<p>هر بار که به طریق مشابه کد را بررسی کنید، مقدار خطوط مشکوک به نصف تقلیل پیدا می‌کند. بعد از شش مرحله، احتمالا به یک یا دو خط کد رسیده‌اید. حداقل در تئوری!</p>
<p>در عمل، وسط یک برنامه همیشه واضح نیست و نمی‌شود که یک قطعه کد در بین آن جا داد و کد را بررسی کرد. در اصل شمارش خطوط و پیدا کردن نقطه‌ی وسط، کار معقولی به نظر نمی‌رسد. در عوض به دنبال قطعه‌هایی از کد که احتمالا خطا در آن‌ها خف کرده بگردید و همان‌ها را بررسی کنید. جایی که احساس می‌کنید خطا از آن ناشی شده را انتخاب کرده و سپس با استفاده از ابزارهایی مثل print سعی کنید از مشکل سر در بیاورید.</p>
<h2>واژگان فصل</h2>
<p><strong>انباشتگر / Accumulator:</strong><br />
متغیری‌ست در یک حلقه برای افزایش یا انباشتن یک برآیند یا نتیجه.</p>
<p><strong>شمارنده / Counter:</strong><br />
متغیری‌ست در یک حلقه که برای شمارش تعداد دفعاتی که اتفاقی می‌افتد، به کار می‌رود. ما «شمارنده» را در ابتدا با صفر مقداردهی می‌کنیم و سپس به آن مقداری را &#8211; زمانی که می‌خواهیم، چیزی را بشماریم &#8211; اضافه می‌کنیم.</p>
<p><strong>نزول / Decrement:</strong><br />
به‌روز رسانی‌ای که مقدار یک متغیر را کاهش می‌دهد.</p>
<p><strong>مقداردهی اولیه / Initialize:</strong><br />
گزاره‌ای که در آن به یک متغیر، مقدار اولیه داده می‌شود. این متغیر در ادامه به‌روزرسانی خواهد شد.</p>
<p><strong>صعود / Increment:</strong><br />
به‌روز رسانی‌ای که مقدار یک متغیر را افزایش می‌دهد.</p>
<p><strong>حلقه بی‌نهایت / Infinite Loop:</strong><br />
حلقه‌ای که شرط آن هیچگاه «غلط» نمی‌شود؛ به عبارتی اگر آن حلقه تنها بر مبنای شرط، تکرار شود، آن حلقه برای همیشه، و تا زمان بستن برنامه، تکرار خواهد شد.</p>
<p><strong>تکرار / Iteration:</strong><br />
اجرای تکراری دسته‌ای از گزاره‌ها را Iteration یا تکرار می‌گویند. تکرار می‌تواند هم توسط یک تابع با فراخوانی خودش، هم در یک حلقه صورت پذیرد.</p>
<h2>تمرین‌ها</h2>
<p><strong>تمرین ۱:</strong> برنامه‌ای بنویسید که تا زمانی که کاربر کلمه‌ی &#8220;done&#8221; را تایپ کند، به صورت مکرر از او عدد در خواست کند. سپس با ورود &#8220;done&#8221; سه مقدار «مجموع اعداد»، «تعداد ورودی‌های عددی»، «میانگین اعداد» را چاپ کند. برنامه‌ی شما باید با استفاده از try و except در زمانیکه کاربر ورودی غیرعددی وارد می‌کند به او پیام خطای «Invalid input» را نشان دهد و به سراغ درخواست مجدد عدد برود. به خروجی برنامه‌ی نمونه‌ی ما دقت کنید:</p><pre class="crayon-plain-tag">Enter a number: 4
Enter a number: 5
Enter a number: bad data
Invalid input
Enter a number: 7
Enter a number: done
16 3 5.333333333333333</pre><p><strong>تمرین ۲:</strong> برنامه‌ی دیگری بنویسید که مثل برنامه‌ی بالا یک لیست از اعداد را درخواست کرده، سپس «بزرگ‌ترین» و «کوچک‌ترین» آن‌ها را به جای مقدار «میانگین» چاپ کند.</p>
]]></content:encoded>
			<wfw:commentRss>http://192.168.1.6/1597/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>پایتون برای همه &#124; 27 &#124; تکرار و حلقه while</title>
		<link>http://192.168.1.6/1570/</link>
		<comments>http://192.168.1.6/1570/#respond</comments>
		<pubDate>Wed, 02 Aug 2017 07:50:56 +0000</pubDate>
		<dc:creator><![CDATA[Eman]]></dc:creator>
				<category><![CDATA[برنامه‌نویسی]]></category>
		<category><![CDATA[break]]></category>
		<category><![CDATA[continue]]></category>
		<category><![CDATA[while]]></category>

		<guid isPermaLink="false">https://ilola.ir/?p=1570</guid>
		<description><![CDATA[به‌روز رسانی متغیرها یک الگوی رایج در گزاره‌های گمارشی، دستور آپدیت‌‌کردن یک متغیر است؛ به صورتی که مقدار جدید یک متغیر، به مقدار قبلی آن <a class="mh-excerpt-more" href="http://192.168.1.6/1570/" title="پایتون برای همه &#124; 27 &#124; تکرار و حلقه while">[...]</a>]]></description>
				<content:encoded><![CDATA[<h2>به‌روز رسانی متغیرها</h2>
<p>یک الگوی رایج در گزاره‌های گمارشی، دستور آپدیت‌‌کردن یک متغیر است؛ به صورتی که مقدار جدید یک متغیر، به مقدار قبلی آن وابسته خواهد بود. </p>
<p></p><pre class="crayon-plain-tag">x = x + 1</pre><p> </p>
<p>گزاره‌ی بالا به این معنی‌ست که مقدار فعلی متغیر x را بگیر، عدد ۱ را به آن اضافه کن و در نهایت مقدار x را با مقدار جدید که x + 1 باشد، جایگزین کن.</p>
<p>اگر سعی کنید که یک متغیری که وجود خارجی ندارد را به‌روز کنید، خطایی دریافت خواهید کرد. ولی چرا خطا؟ دلیلش این است که پایتون ابتدا قسمت راست معادله را بررسی و حساب می‌کند؛ سپس مقدار جدید را به قسمت چپ معادله نسبت می‌دهد. وقتی x برای محاسبه در کار نباشد، خطا صادر می‌کند:</p>
<p></p><pre class="crayon-plain-tag">&gt;&gt;&gt; x = x + 1
NameError: name 'x' is not defined</pre><p> </p>
<p>قبل از اینکه بتوانید یک متغیر را به‌روز کنید، بایستی که آن را تعریف کرده باشید. یا به عبارت تخصصی‌تر، یک مقدار اولیه به آن اختصاص داده شده باشد. مثلا در گزاره‌های زیر، ابتدا x را تعریف کرده‌ایم و مقدار 0 را به آن اختصاص داده‌ایم:</p>
<p></p><pre class="crayon-plain-tag">&gt;&gt;&gt; x = 0
&gt;&gt;&gt; x = x + 1</pre><p> </p>
<p>به‌روز رسانی یک متغیر با اضافه کردن عدد یک، «افزونش» یا «افزودن پله‌ای» خوانده می‌شود. اگر مقدار عدد یک را از متغیر کم کنید به آن «نزول» یا «کاستن پله‌ای» می‌گوییم.</p>
<h2>گزاره while</h2>
<p>کامپیوترها اغلب برای انجامِ خودکار کارهای تکراری استفاده می‌شوند. تکرار وظایف مشابه بدون خطا کردن، کاری‌ست که انسان به خوبی از پسش برنمی‌آید، ولی کامپیوتر چرا، برمی‌آید و خیلی خوب هم برمی‌آید! تکرار در همه‌کاری بسیار رایج است، به همین خاطر پایتون به چندین ویژگی مختلف، برای سهولت در آن مجهز شده است.</p>
<p>یک نمونه از تکرار، استفاده از گزاره while است. به مثال زیر نگاه کنید؛ یک برنامه‌ی ساده‌ای که از عدد پنج تا به صفر می‌شمارد و سپس عبارت Blastoff!‎ را چاپ می‌کند:</p>
<p></p><pre class="crayon-plain-tag">n = 5
while n &gt; 0:
    print(n)
    n = n - 1
print('Blastoff!')</pre><p> </p>
<p>گزاره‌ی while را همانگونه که انگلیسی می‌خوانید (به معنای «تا زمانی که:») می‌توانید استفاده کنید. مثال بالا می‌گوید: تا زمانی که n از 0 بزرگتر است، مقدار n را چاپ و سپس عدد یک را از آن کسر کن. زمانی که به 0 رسیدی، از حلقه‌ی while خارج شو و کلمه‌ی Blastoff!‎ را چاپ کن.</p>
<p>حالا اگر بخواهیم جریان اجرای گزاره while را به صورت رسمی‌تر بیان کنیم، سه مرحله‌ی اصلی در پیش رو داریم:</p>
<p>۱. محاسبه‌ی شرط برای دریافت True یا False. به عبارت ساده‌تر، گزاره‌ی while شرط را وارسی کرده و می‌بیند که نتیجه‌ی آن «صحیح» یا «غلط» است.<br />
۲. اگر محاسبه‌ی بالا False یا «غلط» بود، از بدنه while خارج شده و به اجرای گزاره‌ی بعد از آن می‌پردازد.<br />
۳. اگر محاسبه‌ی اولیه True یا «صحیح» بود، بدنه while اجرا می‌شود و دو مرتبه به سراغ محاسبه‌ی شرط گزاره‌ی while (مرحله اول) می‌رود.</p>
<p>ما به این جریانِ اجرا، loop یا حلقه می‌گوییم. ولی چرا حلقه؟ چون در مرحله‌ی سوم، جریان اجرا دور زده و باز به مرحله‌ی اول باز می‌گردد. ما به هر بار که بدنه‌ی این حلقه را اجرا می‌کنیم یک «تکرار» می‌گوییم. برای مثال بالا ما حلقه‌ای داشتیم که در آن پنج تکرار انجام شد. به عبارت ساده‌تر حلقه‌ی ما پنج بار اجرا شد.</p>
<p>بدنه‌ی حلقه بایستی که مقدار یک یا چند متغیر را تغییر دهد؛ به این خاطر که در نهایت نتیجه‌ی شرط (مرحله‌ی اول) «غلط» شود، و برنامه بتواند از بدنه‌ی حلقه خارج شده و به حلقه پایان بخشد. ما به متغیری که با هر بار اجرای حلقه، تغییر می‌کند، و کنترل جریان حلقه را در دست دارد، «متغیر تکرار» می‌گوییم. اگر یک متغیر تکرار در کار نباشد، این حلقه برای همیشه تکرار خواهد شد و نتیجه‌ی آن یک «حلقه بی‌نهایت» خواهد بود.</p>
<h2>حلقه‌های بی‌نهایت</h2>
<p>برای یک برنامه‌نویس، دستورالعمل یک شامپو هم سرگرم‌کننده است. چرا؟ دستور العمل شامپو می‌گوید: ۱) شامپو را به سرتان بزنید، ۲) آب بکشید، ۳) تکرار کنید. ولی اثری متغیرِ تکرار در کار نیست که شخص بداند بایستی چند بار این عمل را تکرار کند.</p>
<p>در حالت شمارش معکوس، ما می‌دانیم که n یک عدد متناهی است، در نتیجه با کم شدن مقدار از آن، در نهایت به صفر رسیده و حلقه به پایان می‌رسد. در حالت‌هایی که متغیر تکرار در کار نیست، حلقه، یک حلقه‌ی بی‌نهایت خواهد بود. البته حلقه‌ی بی‌نهایت می‌تواند با وجود متغیر تکرار نیز اتفاق بیفتد. مثلاً فرض کنید که در مثال پیشین به اشتباه به جای کم کردن مقدار n به آن اضافه کنید. در این سناریو n هیچ‌وقت به عدد صفر نخواهد رسید و حلقه برای همیشه و تا زمانی که کامپیوتر ظرفیتش را دارد، تکرار خواهد شد.</p>
<h2>حلقه‌های بی‌نهایت و break</h2>
<p>گاهی تا زمانی که به اواسط بدنه‌ی حلقه نرسید، نمی‌دانید که باید این حلقه را تمام کنید یا نه. در این زمان می‌توانید که یک حلقه‌ی بی‌نهایت را از عمد بنویسید و سپس با استفاده از گزاره break از حلقه بیرون بپرید.</p>
<p>حلقه‌ی زیر، یک حلقه‌ی بی‌نهایت است چرا که در جلوی گزاره‌ی while عبارت منطقی بی‌تغییر True نوشته شده و این شرط همیشه «صحیح» است:</p>
<p></p><pre class="crayon-plain-tag">n = 10
while True:
    print(n, end=' ')
    n = n - 1
print('Done!')</pre><p> </p>
<p>اگر کد بالا را اجرا کنید، خواهید فهمید که حلقه‌ی بی‌نهایت تا زمانی که برنامه را متوقف نکنید، تکرار خواهد شد. باید راهی برای خاتمه‌دادن به برنامه پیدا کنید، یا به دکمه‌ی پاور کامپیوتر متوسل شوید. به این دلیل که شرط while همیشه «صحیح» است این برنامه تا همیشه اجرا خواهد شد.</p>
<p>پس به نظر می‌رسد که استفاده از عبارت منطقیِ بی‌تغییر در حلقه، کار بیهوده‌ای است. با این حال شما می‌توانید حلقه‌های مفید با استفاده از این الگو بسازید. ولی چگونه؟ با استفاده از کدی که جریانِ اجرا را از حلقه خارج کند. شما می‌توانید از break، البته با دقت و به جا، استفاده کرده و یک حلقه‌ی بی‌نهایت را بشکنید.</p>
<p>برای نمونه فرض کنید که شما می‌خواهید که کاربر مدام ورودی به برنامه بفرستد و این کار تنها زمانی به پایان برسد که کاربر عبارت done را تایپ کند. کد زیر را ببینید:</p>
<p></p><pre class="crayon-plain-tag">while True:
    line = input('&gt; ')
    if line == 'done':
        break
    print(line)
print('Done!')

# Code: http://www.py4e.com/code3/copytildone1.py</pre><p> </p>
<p>شرط حلقه‌ی True است و به این خاطر که یک مقدار ثابت است، حلقه‌ی ما بی‌نهایت خواهد بود. ولی زمانی که شرط  داخل بدنه‌ی حلقه درست از آب در بیاید، گزاره‌ی break اجرا شده و ما از حلقه خارج می‌شویم. </p>
<p>در برنامه‌ی بالا، پایتون مدام از کاربر ورودی می‌خواهد. اگر کاربر عبارت done را تایپ نماید، با اجرا شدن گزاره‌ی break جریان اجرا به خارج از حلقه پرش می‌کند. در غیر این صورت، برنامه هر چیزی که کاربر تایپ کند را تکرار می‌کند:</p>
<p></p><pre class="crayon-plain-tag">&gt; hello there
hello there
&gt; finished
finished
&gt; done
Done!</pre><p> </p>
<p>این روش نوشتن حلقه‌های while بسیار رایج است، چرا که شما می‌توانید در هر جای حلقه که خواستید، شرط لازم برای ادامه‌ی آن را تعریف کنید. همچنین می‌توانید به برنامه به جای اینکه بگویید «آنقدر حلقه را ادامه بده تا این اتفاق بیفتد» بگویید «وقتی این اتفاق افتاد، در جا حلقه را تمام کن».</p>
<h2>پایان دادن به تکرار با استفاده از continue</h2>
<p>گاهی در حین تکرار حلقه می‌خواهید که تکرارِ جاری را تمام کرده و سریع به سراغ تکرار بعدی بروید، بدون اینکه گزاره‌های بعدی موجود در حلقه، در آن تکرار اجرا شوند. اینجاست که از گزاره continue استفاده می‌کنیم.</p>
<p>بهتر است قضیه را با یک مثال روشن‌تر کنیم. کد زیر را در نظر بگیرید. این کد، ورودی کاربر را گرفته و تا زمانی که کاربر done را وارد کند، آن‌ها را چاپ می‌کند. ولی یک استثنا این وسط وجود دارد. اگر کاربر رشته‌ای وارد کند که با # شروع شده باشد، برنامه آن را چاپ نخواهد کرد و به سراغ دریافت مجدد ورودی از کاربر می‌رود.</p>
<p></p><pre class="crayon-plain-tag">while True:
    line = input('&gt; ')
    if line[0] == '#':
        continue
    if line == 'done':
        break
    print(line)
print('Done!')

# Code: http://www.py4e.com/code3/copytildone2.py</pre><p> </p>
<p>برنامه را بنویسید و اجرا کنید. یک نمونه از اجرای آن را در پایین آورده‌ایم:</p>
<p></p><pre class="crayon-plain-tag">&gt; hello there
hello there
&gt; # don't print this
&gt; print this!
print this!
&gt; done
Done!</pre><p> </p>
<p>تمام خطوط غیر از آن خطی که با علامت هش شروع شده بود، چاپ شدند. دلیلش این است که آن رشته، شرط موجود در بدنه‌ی حلقه را محقق کرده و گزاره‌ی continue اجرا می‌شد. با اجرا شدن continue، جریان اجرا بدون اجرا کردن ادامه‌ی گزاره‌های حلقه، به سراغ تکرار بعدی می‌رود. به همین خاطر در آن مورد خاص، برنامه از اجرای گزاره‌ی print باز ماند.</p>
<p>این نوشته تحت مجوز کرییتیو کامنز BY – NC و حمایت موسسه تحقیقاتی رامونا ارائه می‌شود. شما می‌توانید با توجه به مفاد این گواهی از آن استفاده کنید.</p>
]]></content:encoded>
			<wfw:commentRss>http://192.168.1.6/1570/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>پایتون برای همه &#124; 26 &#124; پارامترها و آرگویمنت‌ها &#124; تمرین‌ها و واژگان فصل ۴</title>
		<link>http://192.168.1.6/1564/</link>
		<comments>http://192.168.1.6/1564/#respond</comments>
		<pubDate>Tue, 01 Aug 2017 08:29:57 +0000</pubDate>
		<dc:creator><![CDATA[Eman]]></dc:creator>
				<category><![CDATA[برنامه‌نویسی]]></category>

		<guid isPermaLink="false">https://ilola.ir/?p=1564</guid>
		<description><![CDATA[پارامترها و آرگویمنت‌ها بعضی از توابع توکاری‌شده‌ای که تاکنون استفاده کرده‌ایم، به آرگیومنت احتیاج داشتند. به عنوان نمونه زمانی که math.sin را فراخوانی می‌کنیم، یک <a class="mh-excerpt-more" href="http://192.168.1.6/1564/" title="پایتون برای همه &#124; 26 &#124; پارامترها و آرگویمنت‌ها &#124; تمرین‌ها و واژگان فصل ۴">[...]</a>]]></description>
				<content:encoded><![CDATA[<h2>پارامترها و آرگویمنت‌ها</h2>
<p>بعضی از توابع توکاری‌شده‌ای که تاکنون استفاده کرده‌ایم، به آرگیومنت احتیاج داشتند. به عنوان نمونه زمانی که math.sin را فراخوانی می‌کنیم، یک عدد به عنوان آرگیومنت به آن می‌فرستیم. گاهی توابع بیش از یک آرگیومنت را دریافت می‌کنند. مثلا math.pow دو آرگیومنت می‌گیرد، ۱) پایه و ۲) توان.</p>
<p>در داخل تابع، آرگیومنت‌ها به متغیرهایی – که آن‌ها را پارامتر می‌نامیم – اختصاص داده می‌شوند. بهتر است نگاهی به مثال زیر بیندازیم. در این مثال کاربر یک تابع که یک آرگیومنت دریافت می‌کند را تعریف کرده است:</p><pre class="crayon-plain-tag">def print_twice(bruce):
print(bruce)
print(bruce)</pre><p>این تابع یک آرگیومنت را به پارامتری که نامش bruce است تخصیص داده است. در مثال بالا زمانی که تابع فراخوانده می‌شود، مقدار پارامتر (هر چیزی که باشد) دو بار چاپ می‌شود.<br />
این تابع با هر مقداری که قابل چاپ باشد، کار خواهد کرد.</p><pre class="crayon-plain-tag">&gt;&gt;&gt; print_twice('Spam')
Spam
Spam
&gt;&gt;&gt; print_twice(17)
17
17
&gt;&gt;&gt; import math
&gt;&gt;&gt; print_twice(math.pi)
3.141592653589793
3.141592653589793</pre><p>قوانینی که برای توابع توکاری‌شده صادق است، برای توابعی که کاربر تعریف کرده نیز صدق می‌کند، در نتیجه از هر عبارتی به عنوان آرگیومنت برای تابع print_twice می‌توانیم بهره ببریم.</p><pre class="crayon-plain-tag">&gt;&gt;&gt; print_twice('Spam '*4)
Spam Spam Spam Spam
Spam Spam Spam Spam
&gt;&gt;&gt; print_twice(math.cos(math.pi))
-1.0
-1.0</pre><p>آرگیومنت قبل از اینکه تابع فراخوانده شود، بررسی می‌شود. مثلا در مثال ما &#8220;Spam &#8216;*4 و همچنین math.cos(math.pi)‎ تنها یک بار وارسی می‌شوند.</p>
<p>همچنین می‌توانید از متغیر به عنوان یک آرگیومنت بهره ببربید:</p><pre class="crayon-plain-tag">&gt;&gt;&gt; michael = 'Eric, the half a bee.'
&gt;&gt;&gt; print_twice(michael)
Eric, the half a bee.
Eric, the half a bee.</pre><p>نام متغیری که ما به عنوان آرگیومنت (michael) به تابع می‌فرستیم، هیچ دخل و تصرفی در نام پارامتر ما (bruce) ندارد. به عبارتی مقداری که فراخوانی می‌شود &#8211; در اینجا michael – مهم نیست که چه باشد، چون تابع با پارامتری که با آن تعریف شده – در اینجا bruce – کار می‌کند. به عبارت ساده در تابع print_twice ما همه را bruce می‌نامیم، حالا هر آرگیومنتی که می‌خواد وارد تابع شود تفاوتی ایجاد نمی‌کند، چرا که نامش در داخل تابع، bruce خواهد بود.</p>
<h2>توابع نتیجه‌ده و توابع بی‌نتیجه</h2>
<p>برخی از توابع، مانند تابع ریاضی، نتیجه را صادر کرده و برمی‌گرداند. من به این توابع، «توابع باثمر» یا «نتیجه‌ده» می‌گویم. باقی توابع، مانند print_twice، کاری را انجام می‌دهند، ولی نتیجه‌ای را برنمی‌گردانند. به آن‌ها «توابع بی‌نتیجه» یا «وُید» می‌گویند.</p>
<p>زمانی که یک تابع نتیجه‌ده را احضار می‌کنید، تقریبا همیشه قرار است با نتیجه‌ای که برمی‌گرداند کاری را انجام دهید. به عنوان مثال آن را به یک متغیر اختصاص دهید یا به عنوان بخشی از عبارت از آن بهره ببرید:</p><pre class="crayon-plain-tag">x = math.cos(radians)
golden = (math.sqrt(5) + 1) / 2</pre><p>زمانی که یک تابع را در حالت تعاملی فرا می‌خوانید، پایتون نتیجه‌ی برگردانده شده را نمایش می‌دهد:</p><pre class="crayon-plain-tag">&gt;&gt;&gt; math.sqrt(5)
2.23606797749979</pre><p>ولی در یک اسکریپت اوضاع متفاوت است. اگر در یک اسکریپت شما اطلاعات برگردانده شده توسط تابع را در داخل یک متغیر ذخیره نکنید، هیچ چیزی از آن تابع دستگیرتان نمی‌شود و تمام اطلاعاتش پودر شده و به هوا می‌رود:</p><pre class="crayon-plain-tag">math.sqrt(5)</pre><p>در اسکریپت بالا، ریشه‌ی دوم عدد ۵ گرفته می‌شود ولی از آنجایی که این مقدار در هیچ متغیری ذخیره نمی‌شود یا بر روی خروجی چاپ نمی‌گردد، این محاسبه به هیچ کاری نمی‌آید.<br />
توابع بی‌نتیجه شاید چیزی را بر روی صفحهْ نمایش دهند یا تاثیرات دیگری بر روند برنامه بگذارند ولی آن‌ها نتیجه‌ای را برنمی‌گردانند. اگر سعی کنید که نتیجه را به یک متغیر اختصاص دهید، مقداری که دریافت می‌کنید None خواهد بود. به مثال زیر دقت کنید:</p><pre class="crayon-plain-tag">&gt;&gt;&gt; result = print_twice('Bing')
Bing
Bing
&gt;&gt;&gt; print(result)
None</pre><p>مقدار None برابر با رشته‌ی &#8220;None&#8221; نیست بلکه مقدار ویژه‌ای‌ست که نوع خاصِ خود را دارد.</p><pre class="crayon-plain-tag">&gt;&gt;&gt; print(type(None))
&lt;class 'NoneType'&gt;</pre><p>برای بازگرداندن یک مقدار از یک تابع، ما از گزاره return در تابعِ خود استفاده می‌کنیم. به عنوان مثال می‌توانیم یک تابع بسیار ساده برای جمع دو عدد با نام addtwo به شکل زیر بنویسیم که دو عدد را به عنوان آرگیومنت گرفته و سپس پارامترهایش را با هم جمع زده و مقدارِ حاصل از این معادله را برمی‌گرداند:</p><pre class="crayon-plain-tag">def addtwo(a, b):
added = a + b
return added

x = addtwo(3, 5)
print(x)

# Code: http://www.py4e.com/code3/addtwo.py</pre><p>زمانی که این اسکریپت اجرا می‌شود، گزاره‌ی print عدد ‎8 را چاپ خواهد کرد چرا که تابع addtwo با دو آرگیومنت ‎5 و ‎3 فراخوانی شده است. در درون تابع پارامترهای a و b به ترتیب ‎3 و ‎5 می‌شوند. تابع جمع دو عدد را محاسبه می‌کند و در متغیر محلی خود با نام added ذخیره می‌کند. منظور از «متغیر محلی» متغیری‌ست که در درون تابع تعریف می‌شود و بیرون از تابع اعتباری ندارد. سپس از گزاره‌ی return استفاده کرد و مقدار محاسبه شما را به کدِ فراخوان به عنوان نتیجه‌ی تابع باز می‌گرداند. کدِ فرخوان همان عبارتیست که تابع در آن فراخوانی شده است. سپس نتیجه‌ی برگرداننده شده به متغیر x اختصاص داده شده و در نهایت چاپ می‌شود.</p>
<h2>چرا از توابع استفاده می‌کنیم؟</h2>
<p>خُرد کردن برنامه به توابع مختلف چه مزیت‌هایی دارد؟ در اینجا به دلایلی که به خاطرش ما یه برنامه را به تابع‌ها می‌شکنیم، مرور می‌کنیم:</p>
<p>ساخت یک تابع جدید به شما امکان نام‌گذاری بر روی دسته‌ای از گزاره‌ها را می‌دهد. به این صورت برنامه‌ی شما خواناتر شده، بهتر درک می‌شود و راحت‌تر می‌تواند اشکال‌زدایی شود.</p>
<p>توابع، اندازه‌ی برنامه‌ی ما را کوچکتر می‌کنند. عدم نیاز به تکرار یک سری گزاره که تحت نامی به عنوان تابع در برنامه تعریف کرده‌ایم، به ما این امکان را می‌دهد که برنامه‌های خود را بدون از دست دادن کارایی کوچکتر کنیم. در آینده نیز اگر لازم باشد که سلسله گزاره‌ها را دستکاری کنیم، فقط کافیست که همان تابع را تغییر دهیم و نتیجه‌ی این تغییر را در سرتاسر برنامه ببینیم.</p>
<p>تقسیم یک برنامه‌ی بزرگ به توابع به شما امکان اشکال‌زدایی قسمت‌های مختلف را در آن واحد می‌دهد. سپس می‌توانید این قسمت‌ها را سر هم کنید و در نهایت کل بدنه‌ی برنامه را بسازید.</p>
<p>توابعی که خوب طراحی شده‌اند، می‌توانند توسط برنامه‌های زیادی مورد استفاده قرار بگیرند. زمانی که یک تابع را نوشتید و اشکال‌زدایی کردید، می‌توانید با خیال راحت از آن در سایر برنامه‌های خود نیز استفاده کنید.</p>
<p>در ادامه‌ی این کتاب، ما اغلب از توابع برای توضیح یک مفهوم استفاده می‌کنیم. بخشی از مهارت ساخت و استفاده از توابع، تببین یک ایده یا مفهوم توسط آن است. مثلا شما یک ایده دارید: «پیدا کرد کوچکترین مقدار از یک لیست». در اینجا ما به مهارتی برای ساخت یک تابع – که این ایده را در عمل پیاده کند – احتیاج داریم. در ادامه به شما کد مربوط به چنین تابعی را – که ما min می‌خوانیمش – نشان خواهیم داد. این تابع لیستی از مقادیر را به عنوان آرگیومنت گرفته و کوچکترین مقدار آن لیست را برمی‌گرداند.</p>
<h2>اشکال‌زدایی</h2>
<p>اگر از یک برنامه‌ی ویرایش متن برای نوشتن اسکریپت‌های خود استفاده می‌کنید، احتمالا به مشکل استفاده از اسپیس یا Tab برخواهید خورد. اکثر برنامه‌ها وقتی در حال نوشتن اسکریپت پایتون‌اید، این موضوع را تشخیص می‌دهند و جای Tab را با فاصله عوض می‌کنند ولی بعضی خیر. برای همین بهتر است که خودتان دست به کار شوید و به جای Tab از فاصله استفاده کنید.</p>
<p>اسپیس و Tab معمولا قابل مشاهده نیستند و همین موضوع اشکال‌زدایی در باب این مشکل را سخت می‌کند. بهتر است از ویرایشگری استفاده کنید که وظیفه‌ی تو رفتگی گزاره‌ها را خودش برعهده می‌گیرد.</p>
<p>اشکال‌زدایی – به‌خصوص زمانی که قسمت اشتباهی از برنامه را اجرا می‌کنید – زمان زیادی را از شما خواهد گرفت. مطمئن شوید که در حال اصلاح کدی می‌باشید که اجرایش می‌کنید. اگر مطمئن نیستید که اشکال از کدام قسمتِ کد است می‌توانید چیزی مثل print(&#8220;hello&#8221;)‎ را در آن قسمت کد قرار دهید تا مطمئن شوید جای درستی را ویرایش می‌کنید. اگر hello را در حین اجرا نمی‌بینید، پس جای غلطی را اشکال‌زدایی می‌کنید.</p>
<h2>واژگال فصل</h2>
<p><strong>الگوریتم / Algorithm:</strong><br />
یک پروسه‌ی عمومی برای حل دسته‌ای از مسائل.</p>
<p><strong>آرگیومنت / Argument:</strong><br />
مقداری که به یک تابع ارسال می‌شود. این مقدار به پارامتر متناظر در تابع اختصاص پیدا می‌‌کند.</p>
<p><strong>بدنه / Body:</strong><br />
سلسله گزاره‌های موجود در یک تابع.</p>
<p><strong>ترکیب / Composition:</strong><br />
استفاده از یک عبارت به عنوان بخشی از یک عبارت بزرگ‌تر، یا یک گزاره به عنوان بخشی از یک گزاره‌ی بزرگ‌تر.</p>
<p><strong>قطعی / Deterministic: </strong><br />
قطعی بودن پاسخ هر برنامه در برابر ورودی یکسان.</p>
<p><strong>نماد نقطه‌ای / Dot Notation:</strong><br />
متن یا سینتکسی که توسط آن یک تابع را از یک ماژول دیگر فراخوانی می‌کنیم. به این صورت که ابتدا نام ماژول را آورده و سپس بعد از نقطه، نام تابع موجود در آن را می‌آوریم.</p>
<p><strong>جریانِ اجرا / Flow of Execution:</strong><br />
ترتیبی که در آن گزاره‌ها در جریان راه‌اندازی برنامه، اجرا می‌شوند.</p>
<p><strong>تابع نتیجه‌ده / Fruitful Function:</strong><br />
تابعی که یک مقدار را برمی‌گرداند.</p>
<p><strong>تابع / Function:</strong><br />
سلسله‌ای از گزاره‌ها تحت عنوانِ یک نام که عملیات به‌دردبخوری را انجام می‌دهد. یک تابع ممکن است که آرگیومنت بگیرد یا نگیرد. همچنین ممکن است نتیجه‌ای را برگرداند یا برنگرداند.</p>
<p><strong>فراخوانی تابع / Function Call:</strong><br />
گزاره‌ای که یک تابع را اجرا می‌کند. این گزاره شامل نام تابع و لیست آرگیومنت‌های احتمالی که تابع دریافت می‌کند می‌شود.</p>
<p><strong>تعریف تابع / Function Definition:</strong><br />
گزاره‌ای که یک تابع جدید را با اختصاص نام، پارامتر و گزاره‌هایی که قرار است اجرا شوند، می‌سازد.</p>
<p><strong>فاکنشن آبجکت / Function Object:</strong><br />
مقداری که توسط یک تابع ساخته می‌شود. نام تابع، یک متغیر است که به یک فانکشن آبجکت اشاره دارد.</p>
<p><strong>هدر / Header:</strong><br />
اولین خط در تعریف یک تابع.</p>
<p><strong>درون‌ریزی گزاره / Import Statement:</strong><br />
گزاره‌ای که فایل ماژول را می‌خواند و یک ماژول آبجکت می‌سازد.</p>
<p><strong>ماژول آبجکت / Module Object:</strong><br />
مقداری که توسط گزاره‌ی import ساخته می‌شود. این مقدار دسترسی را به داده‌ها و کدهای تعریف شده در یک ماژول مقدور می‌سازد.</p>
<p><strong>پارامتر / Parameter:</strong><br />
نامی که در داخل یک تابع استفاده می‌شود و به مقداری که از طریق آرگیومنت به تابع داده شده اشاره دارد.</p>
<p><strong>شبه تصادفی / Pseudorandom:</strong><br />
سلسله‌ای از اعداد که به نظر تصادفی می‌آیند ولی توسط عوامل قطعی در برنامه ساخته شده‌اند.</p>
<p><strong>مقدار بازگردانده شده / Return Value:</strong><br />
نتیجه‌ی یک تابع. اگر فراخوانی یک تابع به عنوان یک عبارت استفاده شده باشد، مقداری بازگردانده شده توسط تابع، مقدار عبارت خواهد بود.</p>
<p><strong>تابع بی‌نتیجه / Void Function:</strong><br />
تابعی که مقداری را برنمی‌گرداند.</p>
<h2>تمرین‌ها</h2>
<p>تمرین ۴: هدف کلیدواژه def در پایتون چیست؟</p>
<p>الف) یک اصطلاح که معنی آن «عجب کد باحالی‌ـه» است.<br />
ب) نشان‌دهنده شروع یک تابع است.<br />
پ) نشان‌دهنده این موضوع است که کدهای تو رفته‌ی بعدی برای آینده ذخیره می‌شوند.<br />
ج) گزینه‌ی ب و پ هر دو صحیح است.<br />
د) هیچکدام از موارد بالا.</p>
<p>تمرین ۵: برنامه‌ی زیر، چه عبارتی را چاپ خواهد کرد؟</p><pre class="crayon-plain-tag">def fred():
print("Zap")

def jane():
print("ABC")

jane()
fred()
jane()</pre><p>الف) Zap ABC jane fred jane<br />
ب) Zap ABC Zap<br />
پ) ABC Zap jane<br />
ج) ABC Zap ABC<br />
د) Zap Zap Zap</p>
<p>تمرین ۶: برنامه پرداخت اضافه برای کسانی که بیشتر کار کرده‌اند را بازنویسی کرده و تابعی با نام computepay بسازید که دو پارامتر hours و rate را دریافت و سپس مقدار را محاسبه می‌کند.</p><pre class="crayon-plain-tag">Enter Hours: 45
Enter Rate: 10
Pay: 475.0</pre><p>تمرین ۷: برنامه نمره‌دهیِ فصل قبل را دو مرتبه بنویسید و از یک تابع به اسم computegrade استفاده کنید. این تابع بایستی که نمره را به عنوان پارامتر دریافت کرده و نتیجه را به صورت A یا ‌B یا … برگرداند.</p><pre class="crayon-plain-tag">Score Grade
&gt; 0.9 A
&gt; 0.8 B
&gt; 0.7 C
&gt; 0.6 D
&lt;= 0.6 F</pre><p></p><pre class="crayon-plain-tag">Program Execution:</pre><p></p><pre class="crayon-plain-tag">Enter score: 0.95
A</pre><p></p><pre class="crayon-plain-tag">Enter score: perfect
Bad score</pre><p></p><pre class="crayon-plain-tag">Enter score: 10.0
Bad score</pre><p></p><pre class="crayon-plain-tag">Enter score: 0.75
C</pre><p></p><pre class="crayon-plain-tag">Enter score: 0.5
F</pre><p></p>
<p>این نوشته تحت مجوز کرییتیو کامنز BY – NC و حمایت موسسه تحقیقاتی رامونا ارائه می‌شود. شما می‌توانید با توجه به مفاد این گواهی از آن استفاده کنید.</p>
]]></content:encoded>
			<wfw:commentRss>http://192.168.1.6/1564/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>پایتون برای همه &#124; 25 &#124; توابع ریاضی &#124; جریان اجرا</title>
		<link>http://192.168.1.6/1532/</link>
		<comments>http://192.168.1.6/1532/#respond</comments>
		<pubDate>Sun, 30 Jul 2017 06:14:51 +0000</pubDate>
		<dc:creator><![CDATA[Eman]]></dc:creator>
				<category><![CDATA[برنامه‌نویسی]]></category>

		<guid isPermaLink="false">https://ilola.ir/?p=1532</guid>
		<description><![CDATA[توابع ریاضی [crayon-5bbd1bd249bbd823388746/] اینکار یک ماژل مقصد به اسم math می‌سازد. اگر شما ماژل مقصد را چاپ کنید، اطلاعاتی در خصوص آن در خروجی ظاهر <a class="mh-excerpt-more" href="http://192.168.1.6/1532/" title="پایتون برای همه &#124; 25 &#124; توابع ریاضی &#124; جریان اجرا">[...]</a>]]></description>
				<content:encoded><![CDATA[<h2>توابع ریاضی</h2>
<p></p><pre class="crayon-plain-tag">&gt;&gt;&gt; import math
&gt;&gt;&gt;</pre><p> </p>
<p>اینکار یک ماژل مقصد به اسم math می‌سازد. اگر شما ماژل مقصد را چاپ کنید، اطلاعاتی در خصوص آن در خروجی ظاهر خواهد شد:</p>
<p></p><pre class="crayon-plain-tag">&gt;&gt;&gt; print(math)
&lt;module 'math' (built-in)&gt;</pre><p> </p>
<p>ماژول مقصد شامل توابع و مقادیر مشخص شده‌ایست که دسترسی به آن‌ها را از طریق اسم خاصِ ماژول و اسم خاص تابع ممکن می‌سازد. این دو اسم با یک نقطه از هم جدا می‌شوند. به این قالب dot notation یا «نماد نقطه‌ای» می‌گویند.</p>
<p></p><pre class="crayon-plain-tag">&gt;&gt;&gt; ratio = signal_power / noise_power
&gt;&gt;&gt; decibels = 10 * math.log10(ratio)
&gt;&gt;&gt; radians = 0.7
&gt;&gt;&gt; height = math.sin(radians)</pre><p> </p>
<p>اولین مثال، لگاریتم بر پایه‌ی ۱۰ ــِــ نسبت سیگنال به نویز را محاسبه می‌کند. ماژول math تابعی به اسم log را نیز مهیا می‌کند که لگاریتم بر پایه‌ی e می‌گیرد.<br />
مثال دوم سینوس radians را محاسبه می‌کند. نام متغیر radians در اصل می‌گوید که sin و بقیه توابع مربوط به مثلثات (cos و tan و غیره)، آرگویمنت را به رادیان می‌گیرند.</p>
<p>برای تغییر درجه به رادیان می‌توانید آن را بر ۳۶۰ تقسیم و در 2pi ضرب نمایید:</p>
<p></p><pre class="crayon-plain-tag">&gt;&gt;&gt; degrees = 45
&gt;&gt;&gt; radians = degrees / 360.0 * 2 * math.pi
&gt;&gt;&gt; math.sin(radians)
0.7071067811865476</pre><p> </p>
<p>عبارت math.pi متغیر pi را از ماژول math می‌گیرد. مقدار این متغیر تقریبا برابر با عدد پی است و تا حدود ۱۵ رقم اعشار دقت دارد.<br />
اگر از مثلثات سر در می‌آورید، نتایج پیشین را با مربع ریشه دو، تقسیم بر دو مقایسه کنید.</p>
<p></p><pre class="crayon-plain-tag">math.sqrt(2) / 2.0
0.7071067811865476</pre><p> </p>
<h2>اضافه کردن یک تابع</h2>
<p>تا اینجای کار از توابعی که در خود پایتون وجود داشت استفاده کردیم، ولی پایتون این امکان را به ما می‌دهد که توابع جدید نیز اضافه کنیم. یک شناسانش تابع، نام یک تابع و گزاره‌های آن را تعیین می‌کند. این گزاره‌ها زمانی که تابع فراخوانده می‌شود اجرا می‌گردند. زمانی که یک تابع را تعریف کردید، می‌توانید از آن به تعداد دفعاتی که عشق‌تان کشید دوباره و دوباره استفاده کنید بدون اینکه مجبور باشید کد آن را راه‌به‌راه بنویسید. </p>
<p>مثال:</p>
<p></p><pre class="crayon-plain-tag">def print_lyrics():
    print("I'm a lumberjack, and I'm okay.")
    print('I sleep all night and I work all day.')</pre><p> </p>
<p>کلمه‌ی def در ابتدای کار، یک کلمه‌ی کلیدی (keyword) برای تعریف تابع است. سپس اسم تابع را مشخص می‌کنیم. مثلا در مثال بالا print_lyrics اسم تابع می‌شود. قوانین انتخاب اسمِ متغیرها، برای توابع نیز صادقند. حروف، اعداد و بعضی از علائم مجازند ولی اولین کاراکتر نمی‌تواند که عدد باشد. از کلمات کلیدی برای اسم تابع نبایستی استفاده کنید و بایستی از انتخاب نام یکسان برای یک متغیر و تابع در یک برنامه اجتناب کنید.<br />
پرانتزهای خالی در جلوی یک تابع نشان می‌دهد که این تابع آرگویمنتی را دریافت نمی‌کند. در آینده توابعی خواهیم ساخت که به عنوان ورودی آرگیومنت دریافت می‌کنند.</p>
<p>اولین خط یک تابع را به اسم هدر و بقیه آن را بادی یا بدنه‌ی تابع می‌نامیم. هدر با دو نقطه تمام می‌شود و بدنه با مقداری تورفتگی نسبت هدر در ادامه آورده می‌شود. رسم این است که تورفتگی از چهار فاصله (Space) تشکیل شده باشد. بادی می‌تواند شامل هر مقدار گزاره که نیاز است شود. در اصل محدودیتی در کار نیست.</p>
<p>رشته‌هایی که در گزاره‌ی پرینت آورده می‌شوند بین علامت نقل‌قول قرار می‌گیرند. علامت نقل‌قول به دو صورت &#8216;رشته&#8217; و &#8220;رشته&#8221; استفاده می‌شود. البته از سینگل کوت (&#8216;) بیشتر استفاده می‌کنند. گاهی خودِ رشته مثلاً عبارت It&#8217;s me در درون خود یک سینگل‌کوت دارد. این سینگل‌کوت باعث می‌شود که پایتون گیج شده و با رسیدن به آن، رشته را تمام شده فرض کند. اینجاست که از دابل‌کوت (&#8220;) بایستی استفاده کنیم.</p>
<p>اگر شما یک تابع را در حالت تعاملی پایتون وارد کنید، مفسر علامت (…) را چاپ می‌کند تا به شما نشان دهد نوبت به وارد کردن بدنه‌ی کد در تابع است.</p>
<p></p><pre class="crayon-plain-tag">&gt;&gt;&gt; def print_lyrics():
...     print("I'm a lumberjack, and I'm okay.")
...     print('I sleep all night and I work all day.')
...</pre><p> </p>
<p>برای تمام کردن بدنه در حالت تعاملی، Enter را در یک سطر خالی فشار دهید. یعنی بعد از نوشتن آخرین خط از بادی، دو بار اینتر را بزنید.</p>
<p></p><pre class="crayon-plain-tag">&gt;&gt;&gt; print(print_lyrics)
&lt;function print_lyrics at 0xb7e99e9c&gt;
&gt;&gt;&gt; print(type(print_lyrics))
&lt;class 'function'&gt;</pre><p> </p>
<p>ما به مقدار print_lyrics فانکشن آبجکت (function object) می‌گوییم. فانکشن آبجکت از نوع تابع به حساب می‌آید.</p>
<p>دستورِ فراخوانی یک تابع دقیقا برابر با نام خود تابع است:</p>
<p></p><pre class="crayon-plain-tag">&gt;&gt;&gt; print_lyrics()
I'm a lumberjack, and I'm okay.
I sleep all night and I work all day.</pre><p> </p>
<p>زمانی که یک تابع را تعریف کردید، می‌توانید از آن در داخل توابع دیگر نیز بهره ببرید. مثلا می‌توانیم یک تابع با اسم repeat_lyrics بنویسیم و از print_lyrics در آن استفاده کنیم.</p>
<p></p><pre class="crayon-plain-tag">def repeat_lyrics():
    print_lyrics()
    print_lyrics()</pre><p> </p>
<p>حالا تابع repeat_lyrics را فراخوانی می‌کنیم:</p>
<p></p><pre class="crayon-plain-tag">&gt;&gt;&gt; repeat_lyrics()
I'm a lumberjack, and I'm okay.
I sleep all night and I work all day.
I'm a lumberjack, and I'm okay.
I sleep all night and I work all day.</pre><p> </p>
<p>البته درست است که آهنگ این مدلی نبود ولی خب حداقل یاد گرفتید که یک تابع چطوری کار می‌کند.</p>
<h2>تعریف تابع و استفاده از آن</h2>
<p>کدهای قسمتِ قبل را که سر هم کنیم، کل برنامه چیزی شبیه به این خواهد بود:</p>
<p></p><pre class="crayon-plain-tag">def print_lyrics():
    print("I'm a lumberjack, and I'm okay.")
    print('I sleep all night and I work all day.')

def repeat_lyrics():
    print_lyrics()
    print_lyrics()

repeat_lyrics()

# Code: http://www.py4e.com/code3/lyrics.py</pre><p> </p>
<p>برنامه شامل دو تابعِ تعریف شده به اسم‌های print_lyrics و repeat_lyrics می‌شود. توابعِ تعریف شده دقیقا مثل سایر گزاره‌ها اجرا می‌شوند ولی نتیجه‌ی اجرایشان ساخته شدنِ فانکشن‌آبجکت‌هاست. گزاره‌های داخل تابع تا زمانی که تابع فراخوانی نشود، اجرا نخواهند شد و خودِ تابع هیچ خروجی‌ای را نمی‌سازد.</p>
<p>همانگونه که انتظار می‌رود، قبل از اجرای یک تابع، بایستی که آن را تعریف کرده باشید. به عبارت دیگر، تعریف تابع بایستی که قبل از اولین باری که فراخوانده می‌شود آورده شود.</p>
<p>تمرین ۲: آخرین خط این برنامه یعنی repeat_lyrics()‎ را بچینید و قبل از تعریف توابع قرار دهید. حالا برنامه را اجرا کنید. چه خطایی دریافت می‌کنید؟</p>
<p>آشنا شدن با نوع و خروجی خطاها، باعث می‌شود که شما در آینده و در مواجه به آن‌ها سریع‌تر مشکل را تشخیص دهید.</p>
<p>تمرین ۳: فراخوانی تابع را به پایین اسکریپت برگردانید. حالا تابع print_lyrics را زیر تابع repeat_lyrics قرار دهید. برنامه را اجرا کرده. چه اتفاقی می‌افتد؟</p>
<h2>جریان اجرا</h2>
<p>برای اینکه تشخیص دهید تابع را در کجای یک برنامه تعریف کنید، بایستی بدانید که در چه زمانی برای اولین بار فراخوانده می‌شود. به عبارتی بایستی از جریانِ اجرای یک برنامه مطلع باشید.</p>
<p>اجرا همیشه از اولین خط برنامه آغاز و در هر لحظه یک گزاره به ترتیب از بالا به پایین اجرا می‌شود.</p>
<p>توابع، جریان و روند اجرای یک برنامه را دستکاری نمی‌کنند ولی گزاره‌های داخل یک تابع، تا زمانی که آن تابع فراخوانی نشود، اجرا نخواهند شد. </p>
<p>فراخوانی یک تابع شبیه به یک راه فرعی در درون برنامه و جریان اجراست. به جای اینکه روند اجرای برنامه به خط بعد از تابع برود، مسیرش را به سمت تابع کج کرده و به داخل بدنه‌ی آن می‌پرد. سپس گزاره‌های موجود در بدنه‌ی تابع را اجرا نموده و در نهایت به سر راهی که مسیرش را کج کرده بود برمی‌گردد و جریانِ اجرا را از سر می‌گیرد.</p>
<p>به نظر ساده می‌رسد. ولی خب در جریان اجرای یک تابع ممکن است یک تابع دیگر نیز فراخوانده شود. اوضاع وقتی پیچیده‌تر می‌شود که در جریان اجرای تابع دوم نیز اصلا بعید نیست که یک تابع دیگر فراخوانده و جریان اجرا به سمت آن کج شود. </p>
<p>خوشبختانه پایتون راه‌بلدِ خوبی است و دقیقا می‌داند که هر لحظه در کجای نقشه‌ی برنامه ایستاده و مسیرش به کدام طرف است. هر زمان که کار با یک تابع به سر رسید، پایتون به سر راه قبل از اجرای آن تابع رفته و ادامه‌ی مسیر را از سر می‌گیرد. زمانی هم که به پایان برنامه رسید، آن را خاتمه می‌دهد.</p>
<p>حالا هدف از این قصه‌ی سر در گم ما چه بود؟ خواستیم بگوییم که زمانیکه یک برنامه را می‌خوانید همیشه از بالا به پایین و به ترتیب نخوانید، بلکه بهتر است که جریان اجرا را دنبال کنید. مثلا لازم نیست گزاره‌های یک تابع را تا قبل از فراخوانی آن، صرفا به خاطر اینکه در بالای برنامه قرار گرفته، بخوانید و آنالیز کنید.</p>
<p>این نوشته تحت مجوز کرییتیو کامنز BY – NC و حمایت موسسه تحقیقاتی رامونا ارائه می‌شود. شما می‌توانید با توجه به مفاد این گواهی از آن استفاده کنید.</p>
]]></content:encoded>
			<wfw:commentRss>http://192.168.1.6/1532/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
	</channel>
</rss>
